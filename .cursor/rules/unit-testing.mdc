---
description: Comprehensive unit testing coverage rules and patterns for DMTools
globs: **/*Test.java,**/test/**/*.java
---

# Unit Testing Coverage Rules

## Mandatory Testing Requirements

### CRITICAL Testing Rules
- **ALL business logic MUST be covered by comprehensive unit tests**
- **NO production code without corresponding tests**
- **Test coverage is NON-NEGOTIABLE**
- If tests cannot be written, provide detailed explanation why testing is not applicable

## Testing Framework Stack

### Core Testing Libraries
- **JUnit 4.13.2**: Legacy test compatibility and existing tests
- **JUnit Jupiter 5.9.1**: Preferred for new tests
- **Mockito Core 5.14.2**: Standard mocking framework
- **Mockito Inline 5.2.0**: For mocking final classes and static methods
- **PowerMock 2.0.9**: Advanced mocking (use sparingly)
- **JUnit Vintage 5.8.2**: JUnit 4 compatibility runtime

### Test Types by Module

#### dmtools-core Testing
- **Unit Tests**: `src/test/java/` - Business logic testing
- **Integration Tests**: `src/integrationTest/java/` - External service integration
- **Test Resources**: `src/test/resources/` - Test data and configuration

#### dmtools-server Testing
- **Unit Tests**: Spring Boot test framework
- **Integration Tests**: TestContainers for database testing
- **Web Layer Tests**: MockMvc for REST API testing
- **Security Tests**: Spring Security test framework

## Test Execution Configuration

### JVM Configuration
```gradle
test {
    useJUnitPlatform()
    jvmArgs '-Dnet.bytebuddy.experimental=true'
    jvmArgs '-XX:+EnableDynamicAgentLoading'
    jvmArgs '-javaagent:' + configurations.testRuntimeClasspath.find { it.name.contains('mockito-core') }
    testLogging {
        events "passed", "skipped", "failed", "standardOut", "standardError"
        exceptionFormat "full"
    }
    finalizedBy jacocoTestReport
}
```

### Coverage Requirements
- **Target**: Minimum 80% line coverage for all business logic
- **Tool**: JaCoCo for coverage reporting
- **Reporting**: Both XML and HTML reports required
- **CI Integration**: Coverage reports uploaded to build artifacts

## Testing Patterns and Best Practices

### Test Class Naming
- Test classes: `ClassNameTest.java`
- Integration tests: `ClassNameIntegrationTest.java`
- Test methods: `testMethodName_scenario_expectedResult()`

### Test Structure (AAA Pattern)
```java
@Test
public void testMethodName_scenario_expectedResult() {
    // Arrange
    SomeClass objectUnderTest = new SomeClass();
    when(mockDependency.someMethod()).thenReturn(expectedValue);
    
    // Act
    String result = objectUnderTest.methodUnderTest(input);
    
    // Assert
    assertEquals(expectedResult, result);
    verify(mockDependency).someMethod();
}
```

### Mocking Guidelines

#### Standard Mocking with Mockito
```java
@Mock
private DependencyClass mockDependency;

@InjectMocks
private ClassUnderTest classUnderTest;

@Before
public void setUp() {
    MockitoAnnotations.openMocks(this);
}
```

#### Advanced Mocking Scenarios
- **Final Classes**: Use Mockito Inline
- **Static Methods**: Use PowerMock sparingly
- **Constructor Mocking**: Use PowerMock when absolutely necessary
- **Spy Objects**: Use `@Spy` for partial mocking

### Testing External Dependencies

#### HTTP Clients Testing
```java
// Mock AbstractRestClient
@Mock
private AbstractRestClient restClient;

@Test
public void testApiCall_success_returnsExpectedData() throws IOException {
    // Arrange
    String expectedResponse = "{\"key\":\"value\"}";
    when(restClient.execute(any(GenericRequest.class))).thenReturn(expectedResponse);
    
    // Act & Assert
    MyApiClient client = new MyApiClient(restClient);
    MyModel result = client.getData();
    assertNotNull(result);
}
```

#### Database Testing
```java
// Use TestContainers for integration tests
@Testcontainers
class DatabaseIntegrationTest {
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:13")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");
}
```

### Agent and Job Testing

#### Agent Testing Pattern
```java
@Test
public void testAgent_executeWithDependencies_returnsExpectedResult() throws Exception {
    // Arrange
    MyAgent agent = new MyAgent("prompt-name");
    MyParams params = new MyParams();
    
    // Mock AI dependency
    when(mockAI.chat(anyString())).thenReturn("AI Response");
    
    // Act
    MyResult result = agent.run(params);
    
    // Assert
    assertNotNull(result);
    verify(mockAI).chat(anyString());
}
```

#### Job Testing Pattern
```java
@Test
public void testJob_runJobImpl_processesTicketsCorrectly() throws Exception {
    // Arrange
    MyJob job = new MyJob();
    MyJobParams params = new MyJobParams();
    
    // Mock tracker client
    when(mockTrackerClient.searchAndPerform(any(), anyString(), any()))
        .thenReturn(expectedResults);
    
    // Act
    List<ResultItem> results = job.run(params);
    
    // Assert
    assertEquals(expectedCount, results.size());
}
```

## Integration Testing Requirements

### JiraMCP Tools Integration Tests
- Located in `dmtools-core/src/integrationTest/java/com/github/istin/dmtools/jira/`
- Tests all 29 MCP-annotated methods
- Requires real Jira instance for testing
- Covers search, ticket management, comments, and project operations

### API Integration Testing
```java
@IntegrationTest
class ApiIntegrationTest {
    @Test
    void testRealApiInteraction() {
        // Test with real external services
        // Use test accounts and data
        // Verify actual integration behavior
    }
}
```

## Test Data Management

### Test Resources
- JSON test data: `src/test/resources/json/`
- Configuration files: `src/test/resources/config/`
- Test images: `src/test/resources/images/`

### Test Data Patterns
```java
// Load test data from resources
private String loadTestJson(String filename) {
    return TestUtils.loadResourceAsString("/json/" + filename);
}

// Create test objects
private MyModel createTestModel() {
    return MyModel.builder()
        .id("test-id")
        .name("Test Name")
        .build();
}
```

## Testing AI Components

### AI Agent Testing
- Mock AI responses for consistent testing
- Test different response scenarios
- Verify prompt construction
- Test error handling for AI failures

### Prompt Testing
```java
@Test
public void testPromptGeneration_withParams_generatesCorrectPrompt() {
    // Test prompt template rendering
    // Verify parameter substitution
    // Check prompt formatting
}
```

## Async and Threading Testing

### Concurrent Testing
```java
@Test
public void testConcurrentAccess_multipleThreads_threadSafe() {
    // Test thread safety
    // Use CountDownLatch for coordination
    // Verify no race conditions
}
```

## Test Execution Commands

### Development Testing
```bash
# Run all tests
./gradlew test

# Run tests with coverage
./gradlew test jacocoTestReport

# Run specific test class
./gradlew test --tests "ClassNameTest"

# Run tests matching pattern
./gradlew test --tests "*Integration*"
```

### CI/CD Testing
```bash
# Full test suite with integration tests
./gradlew clean build integrationTest

# Skip integration tests for faster feedback
./gradlew build -x integrationTest

# Generate coverage reports
./gradlew test jacocoTestReport
```

## Coverage Reporting

### JaCoCo Configuration
- XML reports for CI integration
- HTML reports for local development
- Exclude test classes from coverage
- Set minimum coverage thresholds

### Coverage Analysis
- Review coverage reports after each build
- Identify untested code paths
- Add tests for missing coverage
- Document any legitimate coverage exclusions

## Test Maintenance

### Regular Tasks
- Update test data when APIs change
- Refactor tests when implementation changes
- Remove obsolete tests
- Keep test dependencies up to date

### Test Code Quality
- Apply same coding standards to test code
- Avoid test code duplication
- Use helper methods and utilities
- Keep tests focused and independent

## CRITICAL: Avoiding Common Test Failures

### Spring Boot Test Context Issues

#### ❌ AVOID: @WebMvcTest with Missing Beans
```java
// BAD - Will fail with missing bean errors
@WebMvcTest(MyController.class)
public class MyControllerTest {
    // Spring context tries to load security beans that aren't available
}
```

#### ✅ PREFER: Pure Unit Tests for Controllers
```java
// GOOD - No Spring context, direct method testing
@ExtendWith(MockitoExtension.class)
public class MyControllerTest {
    @Mock
    private MyService mockService;
    
    @Mock
    private Authentication authentication;
    
    @Mock
    private OAuth2User oAuth2User;

    @InjectMocks
    private MyController controller;
    
    @Test
    void testMethod_scenario_expectedResult() {
        // Setup authentication mocks
        when(authentication.getPrincipal()).thenReturn(oAuth2User);
        when(oAuth2User.getAttribute("sub")).thenReturn("user-id");
        
        // Test controller method directly
        ResponseEntity<Void> response = controller.deleteMethod("id", authentication);
        
        assertEquals(HttpStatus.NO_CONTENT, response.getStatusCode());
    }
}
```

#### ✅ ALTERNATIVE: MockMvc Standalone Setup
```java
// GOOD - MockMvc without Spring context
@ExtendWith(MockitoExtension.class)
public class MyControllerTest {
    @InjectMocks
    private MyController controller;
    
    private MockMvc mockMvc;
    
    @BeforeEach
    void setUp() {
        mockMvc = MockMvcBuilders.standaloneSetup(controller).build();
    }
}
```

### Mockito UnnecessaryStubbingException Prevention

#### ❌ AVOID: Global Mock Setup in @BeforeEach
```java
// BAD - Creates unnecessary stubbings for some tests
@BeforeEach
void setUp() {
    when(userRepository.findById(userId)).thenReturn(Optional.of(testUser));
    when(jobConfigRepository.findByIdAndCreatedBy(jobConfigId, testUser))
        .thenReturn(Optional.of(testJobConfig));
}

@Test
void testUserNotFound() {
    // This test overrides the first stubbing but never uses the second
    when(userRepository.findById(userId)).thenReturn(Optional.empty());
    // UnnecessaryStubbingException because jobConfigRepository stubbing is unused
}
```

#### ✅ PREFER: Test-Specific Mock Setup
```java
// GOOD - Each test sets up only what it needs
@BeforeEach
void setUp() {
    // Only create test objects, not mock stubbings
    testUser = new User();
    testUser.setId(userId);
    
    testJobConfig = new JobConfiguration();
    testJobConfig.setId(jobConfigId);
}

@Test
void testSuccess() {
    // Setup only needed mocks for this test
    when(userRepository.findById(userId)).thenReturn(Optional.of(testUser));
    when(jobConfigRepository.findByIdAndCreatedBy(jobConfigId, testUser))
        .thenReturn(Optional.of(testJobConfig));
    
    // Test logic
}

@Test
void testUserNotFound() {
    // Setup only needed mocks for this test
    when(userRepository.findById(userId)).thenReturn(Optional.empty());
    
    // Test logic - no unnecessary stubbings
}
```

#### ✅ ALTERNATIVE: Use @Spy or lenient() Stubbings
```java
// GOOD - Use lenient() for potentially unused stubbings
@BeforeEach
void setUp() {
    lenient().when(userRepository.findById(userId)).thenReturn(Optional.of(testUser));
    lenient().when(jobConfigRepository.findByIdAndCreatedBy(jobConfigId, testUser))
        .thenReturn(Optional.of(testJobConfig));
}
```

### Controller Testing Strategy Decision Tree

1. **Pure Business Logic Testing**: Use `@ExtendWith(MockitoExtension.class)`
   - Direct method calls to controller
   - Mock all dependencies
   - No Spring context
   - **Example**: `JobConfigurationControllerTest`, `JobConfigurationControllerWebhookTest`

2. **Simple HTTP Testing**: Use `MockMvcBuilders.standaloneSetup()`
   - Test HTTP endpoints without Spring context
   - **Example**: `HealthControllerTest`

3. **Full Integration Testing**: Use `@WebMvcTest` with proper test configuration
   - Only when you need Spring Security, validation, etc.
   - Must provide all required beans or use `@MockBean`
   - **Use sparingly**

### Test Failure Debugging Commands

```bash
# Run specific failing test with detailed output
./gradlew :dmtools-server:test --tests "ClassNameTest.methodName" --info

# Run test with debug logging
./gradlew :dmtools-server:test --tests "ClassNameTest" --debug

# Check test reports
open dmtools-server/build/reports/tests/test/index.html
```

### Test Stability Rules

#### MANDATORY Practices
- **Each test must be independent** - No shared state between tests
- **Setup only what each test needs** - Avoid global @BeforeEach stubbings
- **Use descriptive test names** - `testMethod_scenario_expectedResult()`
- **Clean test data** - Reset/clean state after each test
- **Mock external dependencies** - Never call real services in unit tests
- **Test one thing at a time** - Single responsibility per test method

#### FORBIDDEN Practices
- ❌ Shared mutable state between tests
- ❌ Global mock stubbings that aren't used by all tests
- ❌ Testing multiple scenarios in one test method
- ❌ Depending on test execution order
- ❌ Using real external services in unit tests
- ❌ Catching and ignoring exceptions without assertions