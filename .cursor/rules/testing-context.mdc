DMTOOLS QUICK TESTING COMMANDS:

Use these simple commands to quickly test your Java code changes during development.

** QUICK TEST COMMANDS **

Test specific class:
./gradlew test --tests "ClassName"
./gradlew test --tests "com.github.istin.dmtools.ClassName"

Test specific method:
./gradlew test --tests "ClassName.methodName"

Test entire module (fast):
./gradlew :dmtools-core:test
./gradlew :dmtools-server:test

Test with compilation check:
./gradlew compileJava compileTestJava

Quick compile check:
./gradlew classes testClasses

** PROJECT MODULES **
- dmtools-core: Business logic, integrations (no Spring dependencies)
- dmtools-server: Web services, Spring Boot, authentication

** IMPORTANT: DO NOT MODIFY **
- Java version in build.gradle files - MUST BE JavaVersion.VERSION_23 everywhere, configurations work correctly
- Dependencies in build.gradle - most dependencies already exist, only add if specifically required by task

** COMMON TEST FIXES **

Spring Boot configuration missing - add to test class:
@SpringBootTest
@ContextConfiguration(classes = {YourMainApplication.class})

Authentication issues - add to test:
@WithMockUser

Missing Spring beans - add to test class:
@MockBean
private YourService yourService;

Configuration issues - add to test class:
@TestConfiguration
static class TestConfig {
    @Bean @Primary
    YourConfigClass config() { return new YourConfigClass(); }
}

OAuth2 ClientRegistration empty - provide test registration:
ClientRegistration.withRegistrationId("test")
    .clientId("test-client")
    .clientSecret("test-secret")
    .authorizationUri("http://test")
    .tokenUri("http://test")
    .userInfoUri("http://test")
    .build()

Unnecessary Mockito stubbing - use lenient:
@Mock(lenient = true)
or
lenient().when(mockService.method()).thenReturn(value)

Exception testing - verify behavior correctly:
// Test should actually trigger the exception condition
// Check mocks are set up to cause the expected failure path

** QUICK DEBUGGING **
See failure details:
./gradlew test --tests "ClassName" --info

Clean and retry:
./gradlew clean test --tests "ClassName"

** SPRING SECURITY TEST PATTERNS **

OAuth2 testing setup:
@SpringBootTest
@AutoConfigureTestDatabase
@TestPropertySource(properties = {
    "auth.enabled-providers=test",
    "auth.permitted-email-domains=test.com"
})

Security configuration testing:
@WebMvcTest(SecurityConfig.class)
@Import({SecurityConfig.class, AuthConfigProperties.class})

Mock OAuth2 user for testing:
OAuth2User mockUser = mock(OAuth2User.class);
when(mockUser.getAttribute("email")).thenReturn("test@test.com");

Test ClientRegistrationRepository without empty registrations:
// Always provide at least one test registration
List<ClientRegistration> registrations = Arrays.asList(testRegistration);

** OAUTH2/SPRING SECURITY TEST FIXING STRATEGY **

When you encounter OAuth2/WebMvcTest compilation errors, follow this EXACT sequence:

1. **FIRST: Fix @WebMvcTest annotation syntax**
   - ‚ùå WRONG: @WebMvcTest(MyController.class, properties = "auth.enabled-providers=google")
   - ‚úÖ CORRECT: @WebMvcTest(MyController.class)
                @TestPropertySource(properties = "auth.enabled-providers=google")

2. **SECOND: Choose ONE approach (don't overthink):**
   
   **Option A - Enable OAuth2 (for OAuth2 functionality tests):**
   ```java
   @WebMvcTest(MyController.class)
   @TestPropertySource(properties = "auth.enabled-providers=google")
   @Import({SecurityConfig.class, AuthConfigProperties.class})
   ```
   
   **Option B - Disable OAuth2 (for non-OAuth2 tests):**
   ```java
   @WebMvcTest(MyController.class) 
   @TestPropertySource(properties = "auth.enabled-providers=")
   ```

3. **THIRD: If OAuth2 enabled, add required beans:**
   ```java
   @TestConfiguration
   static class TestConfig {
       @Bean @Primary
       public ClientRegistrationRepository clientRegistrationRepository() {
           ClientRegistration registration = ClientRegistration
               .withRegistrationId("google")
               .clientId("test-client")
               .clientSecret("test-secret")
               .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
               .redirectUri("http://localhost/login/oauth2/code/google")
               .authorizationUri("https://accounts.google.com/o/oauth2/auth")
               .tokenUri("https://oauth2.googleapis.com/token")
               .userInfoUri("https://www.googleapis.com/oauth2/v2/userinfo")
               .build();
           return new InMemoryClientRegistrationRepository(registration);
       }
   }
   ```

4. **DECISION RULE: Stop analysis, pick approach, implement**
   - If test name contains "OAuth2" or "Login" ‚Üí Use Option A
   - If test checks basic controller functionality ‚Üí Use Option B
   - Don't spend time analyzing "what should be tested" - just fix the compilation error

** ANTI-ANALYSIS-PARALYSIS RULES **

üö´ **STOP** endless commenting about "what the test should do"
‚úÖ **START** by fixing the immediate compilation error
üö´ **STOP** writing multiple paragraphs about different approaches  
‚úÖ **START** implementing the first viable solution
üö´ **STOP** second-guessing - if it compiles and the test makes sense, commit it

** COMMON TEST ANTI-PATTERNS TO AVOID **

‚ùå Empty ClientRegistration list - causes "registrations cannot be empty"
‚ùå Missing @SpringBootTest when testing Spring components 
‚ùå Unnecessary mock stubs - clean up unused when() calls
‚ùå Testing exceptions without proper mock setup to trigger them
‚ùå Using @WebMvcTest without importing required security configs
‚ùå Analysis paralysis - endless comments without action

** BEFORE COMMIT **
Quick validation:
./gradlew :dmtools-core:test :dmtools-server:test