package com.github.istin.dmtools.common.kb.utils;

import com.github.istin.dmtools.common.kb.KBStatistics;
import com.github.istin.dmtools.common.kb.KBStructureBuilder;
import com.github.istin.dmtools.common.kb.model.AnalysisResult;
import com.github.istin.dmtools.common.kb.model.Question;
import com.github.istin.dmtools.common.kb.model.Answer;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests for KBStructureManager ID mapping timing.
 * 
 * CRITICAL REGRESSION TEST: Verify that person contributions are collected AFTER ID mapping,
 * not before. This prevents temporary IDs (q_1, q_2) from appearing in person profiles
 * instead of permanent IDs (q_0001, q_0002).
 * 
 * Bug scenario (before fix):
 * 1. AI generates: q_1, q_2, q_3 (temporary IDs)
 * 2. collectPersonContributions() called → collected q_1, q_2, q_3 ❌
 * 3. ID mapper runs → q_0001, q_0002, q_0003 (permanent IDs)
 * 4. Files created with permanent IDs
 * 5. Person profiles merge temporary IDs from step 2 with permanent IDs from files
 * 6. RESULT: Duplicates! (q_1 + q_0001, q_6 + q_0006)
 */
class KBStructureManagerIdMappingTest {

    private static final Logger logger = LogManager.getLogger(KBStructureManagerIdMappingTest.class);

    @TempDir
    Path tempDir;

    private KBStructureManager structureManager;

    @BeforeEach
    void setUp() {
        KBFileParser fileParser = new KBFileParser();
        KBStructureBuilder structureBuilder = new KBStructureBuilder();
        KBContextLoader contextLoader = new KBContextLoader(fileParser);
        PersonStatsCollector statsCollector = new PersonStatsCollector(fileParser, structureBuilder);
        KBStatistics statistics = new KBStatistics();
        structureManager = new KBStructureManager(structureBuilder, statsCollector, statistics, contextLoader);
    }

    /**
     * CRITICAL TEST: Verify person profiles contain ONLY permanent IDs (q_0001) not temporary (q_1)
     */
    @Test
    void testPersonContributions_UsePermanentIdsNotTemporary() throws Exception {
        // GIVEN: Analysis with temporary IDs (as generated by AI)
        AnalysisResult analysis = new AnalysisResult();
        
        Question q1 = new Question();
        q1.setId("q_1");  // Temporary ID from AI
        q1.setAuthor("John Smith");
        q1.setArea("testing");
        q1.setTopics(Arrays.asList("unit-tests"));
        q1.setDate("2025-10-24T10:00:00Z");
        
        Question q2 = new Question();
        q2.setId("q_2");  // Temporary ID from AI
        q2.setAuthor("John Smith");
        q2.setArea("testing");
        q2.setTopics(Arrays.asList("integration-tests"));
        q2.setDate("2025-10-24T11:00:00Z");
        
        analysis.setQuestions(Arrays.asList(q1, q2));
        analysis.setAnswers(Arrays.asList());
        analysis.setNotes(Arrays.asList());
        
        // WHEN: Process (ID mapping happens inside buildStructure)
        structureManager.buildStructure(analysis, tempDir, "session_1", null, logger);
        
        // THEN: Person profile should contain PERMANENT IDs (q_0001, q_0002), NOT temporary (q_1, q_2)
        Path profileFile = tempDir.resolve("people/John_Smith/John_Smith.md");
        assertTrue(Files.exists(profileFile), "Profile should exist");
        
        String content = Files.readString(profileFile);
        
        // Should contain permanent IDs
        assertTrue(content.contains("q_0001"), "Should contain permanent ID q_0001");
        assertTrue(content.contains("q_0002"), "Should contain permanent ID q_0002");
        
        // Should NOT contain temporary IDs
        assertFalse(content.contains("[[../../questions/q_1|q_1]]"), 
            "Should NOT contain temporary ID q_1 in link format");
        assertFalse(content.contains("[[../../questions/q_2|q_2]]"), 
            "Should NOT contain temporary ID q_2 in link format");
        
        // Verify frontmatter stats are correct
        assertTrue(content.contains("questionsAsked: 2"), "Should show 2 questions");
    }

    /**
     * TEST: Verify no duplicates when processing multiple sessions with ID mapping
     */
    @Test
    void testNoDuplicates_WhenIdsMappedAcrossSessions() throws Exception {
        // GIVEN: First session with temporary IDs
        AnalysisResult session1 = new AnalysisResult();
        Question q1 = new Question();
        q1.setId("q_1");  // Temporary
        q1.setAuthor("Alice");
        q1.setArea("ai");
        q1.setTopics(Arrays.asList("topic1"));
        q1.setDate("2025-10-24T10:00:00Z");
        session1.setQuestions(Arrays.asList(q1));
        session1.setAnswers(Arrays.asList());
        session1.setNotes(Arrays.asList());
        
        // WHEN: Process session 1
        structureManager.buildStructure(session1, tempDir, "session_1", null, logger);
        
        // THEN: Profile should have q_0001
        Path profileFile = tempDir.resolve("people/Alice/Alice.md");
        String content1 = Files.readString(profileFile);
        assertTrue(content1.contains("q_0001"), "Session 1 should have q_0001");
        assertFalse(content1.contains("q_1"), "Session 1 should NOT have q_1");
        
        // GIVEN: Second session with NEW temporary IDs
        AnalysisResult session2 = new AnalysisResult();
        Question q2 = new Question();
        q2.setId("q_1");  // SAME temporary ID (AI starts from q_1 again)
        q2.setAuthor("Alice");
        q2.setArea("ai");
        q2.setTopics(Arrays.asList("topic2"));
        q2.setDate("2025-10-24T12:00:00Z");
        session2.setQuestions(Arrays.asList(q2));
        session2.setAnswers(Arrays.asList());
        session2.setNotes(Arrays.asList());
        
        // WHEN: Process session 2
        structureManager.buildStructure(session2, tempDir, "session_2", null, logger);
        
        // THEN: Profile should have BOTH q_0001 (from session 1) and q_0002 (from session 2)
        String content2 = Files.readString(profileFile);
        
        assertTrue(content2.contains("q_0001"), "Should still have q_0001 from session 1");
        assertTrue(content2.contains("q_0002"), "Should have q_0002 from session 2");
        
        // Count occurrences - each should appear exactly once
        int count0001 = countOccurrences(content2, "[[../../questions/q_0001|q_0001]]");
        int count0002 = countOccurrences(content2, "[[../../questions/q_0002|q_0002]]");
        
        assertEquals(1, count0001, "q_0001 should appear exactly once");
        assertEquals(1, count0002, "q_0002 should appear exactly once");
        
        // Should NOT contain temporary IDs
        assertFalse(content2.contains("[[../../questions/q_1|q_1]]"), 
            "Should NOT contain temporary ID q_1");
        
        // Should have 2 questions total
        assertTrue(content2.contains("questionsAsked: 2"), "Should show 2 questions");
    }

    /**
     * TEST: Verify temporary IDs are correctly mapped for answers too
     */
    @Test
    void testAnswers_UsePermanentIdsNotTemporary() throws Exception {
        // GIVEN: Analysis with temporary answer IDs
        AnalysisResult analysis = new AnalysisResult();
        
        Answer a1 = new Answer();
        a1.setId("a_1");  // Temporary ID
        a1.setAuthor("Bob");
        a1.setArea("development");
        a1.setTopics(Arrays.asList("java"));
        a1.setDate("2025-10-24T10:00:00Z");
        
        Answer a2 = new Answer();
        a2.setId("a_2");  // Temporary ID
        a2.setAuthor("Bob");
        a2.setArea("development");
        a2.setTopics(Arrays.asList("kotlin"));
        a2.setDate("2025-10-24T11:00:00Z");
        
        analysis.setQuestions(Arrays.asList());
        analysis.setAnswers(Arrays.asList(a1, a2));
        analysis.setNotes(Arrays.asList());
        
        // WHEN: Process
        structureManager.buildStructure(analysis, tempDir, "session_1", null, logger);
        
        // THEN: Profile should have permanent answer IDs
        Path profileFile = tempDir.resolve("people/Bob/Bob.md");
        String content = Files.readString(profileFile);
        
        assertTrue(content.contains("a_0001"), "Should contain permanent ID a_0001");
        assertTrue(content.contains("a_0002"), "Should contain permanent ID a_0002");
        
        assertFalse(content.contains("[[../../answers/a_1|a_1]]"), 
            "Should NOT contain temporary ID a_1");
        assertFalse(content.contains("[[../../answers/a_2|a_2]]"), 
            "Should NOT contain temporary ID a_2");
    }

    /**
     * TEST: Verify IDs in question files themselves are permanent
     */
    @Test
    void testQuestionFiles_HavePermanentIds() throws Exception {
        // GIVEN: Analysis with temporary question ID
        AnalysisResult analysis = new AnalysisResult();
        Question q = new Question();
        q.setId("q_42");  // Temporary ID
        q.setAuthor("Charlie");
        q.setArea("testing");
        q.setTopics(Arrays.asList("automation"));
        q.setDate("2025-10-24T10:00:00Z");
        analysis.setQuestions(Arrays.asList(q));
        analysis.setAnswers(Arrays.asList());
        analysis.setNotes(Arrays.asList());
        
        // WHEN: Process
        structureManager.buildStructure(analysis, tempDir, "session_1", null, logger);
        
        // THEN: Question file should be named with permanent ID
        Path questionsDir = tempDir.resolve("questions");
        assertTrue(Files.exists(questionsDir), "Questions directory should exist");
        
        // Should have q_0001.md (permanent ID)
        Path questionFile = questionsDir.resolve("q_0001.md");
        assertTrue(Files.exists(questionFile), "Question file should have permanent ID (q_0001.md)");
        
        // Should NOT have q_42.md (temporary ID)
        Path tempQuestionFile = questionsDir.resolve("q_42.md");
        assertFalse(Files.exists(tempQuestionFile), "Should NOT have temporary ID file (q_42.md)");
        
        // File content should also use permanent ID
        String questionContent = Files.readString(questionFile);
        assertTrue(questionContent.contains("id: \"q_0001\""), "Content should have permanent ID");
    }

    /**
     * CRITICAL REGRESSION TEST: Verify questions are NOT duplicated when they belong to multiple topics.
     * 
     * Bug scenario (from user's screenshot):
     * - q_0006 has 2 topics: "enterprise-jira-limitations" and "workflow-management"
     * - PersonContributions collected q_0006 twice (once per topic)
     * - Profile showed: q_0006, q_0006 (duplicate!)
     * 
     * Expected: q_0006 should appear only once, regardless of how many topics it has.
     */
    @Test
    void testNoDuplicates_WhenQuestionHasMultipleTopics() throws Exception {
        // GIVEN: Question with 2 topics
        AnalysisResult analysis = new AnalysisResult();
        Question q = new Question();
        q.setId("q_1");  // Will be mapped to q_0001
        q.setAuthor("Aliaksandr Raukuts");
        q.setArea("enterprise");
        q.setTopics(Arrays.asList("enterprise-jira-limitations", "workflow-management"));
        q.setDate("2025-10-24T10:00:00Z");
        
        analysis.setQuestions(Arrays.asList(q));
        analysis.setAnswers(Arrays.asList());
        analysis.setNotes(Arrays.asList());
        
        // WHEN: Process (this creates files and profiles)
        structureManager.buildStructure(analysis, tempDir, "session_1", null, logger);
        
        // THEN: Person profile should show q_0001 ONLY ONCE, not twice
        Path profileFile = tempDir.resolve("people/Aliaksandr_Raukuts/Aliaksandr_Raukuts.md");
        assertTrue(Files.exists(profileFile), "Profile should exist");
        
        String content = Files.readString(profileFile);
        
        System.out.println("=== Profile Content ===");
        System.out.println(content);
        System.out.println("=== End ===");
        
        // Count exact link occurrences
        int linkCount = countOccurrences(content, "[[../../questions/q_0001|q_0001]]");
        assertEquals(1, linkCount, 
            "q_0001 should appear EXACTLY ONCE in profile, even though it has 2 topics. Found: " + linkCount);
        
        // Verify frontmatter
        assertTrue(content.contains("questionsAsked: 1"), 
            "Frontmatter should show 1 question (not 2)");
        
        // Verify Topics section
        assertTrue(content.contains("## Topics"), "Should have Topics section");
        assertTrue(content.contains("enterprise-jira-limitations"), "Should list first topic");
        assertTrue(content.contains("workflow-management"), "Should list second topic");
        
        // Topic count should be 1 (unique Q/A/N count, not topic assignments)
        // enterprise-jira-limitations appears in 1 question
        // workflow-management appears in 1 question (same question!)
        String topicsSection = content.substring(content.indexOf("## Topics"));
        assertTrue(topicsSection.contains("1 contribution") || topicsSection.contains("2 contributions"), 
            "Topics section should show contribution counts");
    }

    /**
     * TEST: Verify same behavior for answers with multiple topics
     */
    @Test
    void testNoDuplicates_WhenAnswerHasMultipleTopics() throws Exception {
        // GIVEN: Answer with 3 topics
        AnalysisResult analysis = new AnalysisResult();
        Answer a = new Answer();
        a.setId("a_1");  // Will be mapped to a_0001
        a.setAuthor("Developer");
        a.setArea("coding");
        a.setTopics(Arrays.asList("java", "kotlin", "spring"));
        a.setDate("2025-10-24T10:00:00Z");
        
        analysis.setQuestions(Arrays.asList());
        analysis.setAnswers(Arrays.asList(a));
        analysis.setNotes(Arrays.asList());
        
        // WHEN: Process
        structureManager.buildStructure(analysis, tempDir, "session_1", null, logger);
        
        // THEN: Profile should show a_0001 only once
        Path profileFile = tempDir.resolve("people/Developer/Developer.md");
        String content = Files.readString(profileFile);
        
        int linkCount = countOccurrences(content, "[[../../answers/a_0001|a_0001]]");
        assertEquals(1, linkCount, 
            "a_0001 should appear EXACTLY ONCE, even with 3 topics. Found: " + linkCount);
        
        assertTrue(content.contains("answersProvided: 1"), 
            "Frontmatter should show 1 answer");
    }

    /**
     * Helper to count link occurrences (not just substring)
     */
    private int countOccurrences(String text, String substring) {
        int count = 0;
        int index = 0;
        while ((index = text.indexOf(substring, index)) != -1) {
            count++;
            index += substring.length();
        }
        return count;
    }
}

