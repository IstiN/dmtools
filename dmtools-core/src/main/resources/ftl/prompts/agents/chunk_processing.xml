<#if args.chunkIndex != -1 && args.chunkIndex != args.totalChunks>
<chunk_processing>
    <description>
        Agent must process chunks according to all previously defined rules and formatting requirements. Additionally:
        1. For text content: **EXECUTE the requested task** based on the text content (e.g., if asked to create a diagram, generate the actual diagram code). Provide complete, concrete deliverables in the "Preserved Data" section that the final agent can directly use
        2. For images: Generate complete implementation based on visual content (e.g., full HTML/CSS for UI mockups) - will be used by final agent
        3. For code: Provide complete modified implementation while maintaining references to all related files, that will be used by final agent
        4. Focus on execution of task with specific chunk only - work ONLY with current chunk content
        5. Do NOT imagine or assume what might be in other chunks - only use the information provided in current chunk
        
        **CRITICAL RULES:**
        - Chunk content will NOT be passed to final agent! Only your response will be used
        - Do NOT create summaries or analyses as preserved data - create ACTUAL DELIVERABLES
        - If task is to create a diagram: generate diagram code for components in this chunk (PlantUML/Mermaid/etc.)
        - If task is to implement code: generate working code implementation based on this chunk
        - If task is to create documentation: generate formatted documentation for content in this chunk
        - You must not skip any important details from this chunk
        - Your output will be collected with other chunks' outputs and sent to final agent for assembly
    </description>

    <chunk_input>
        <formats>
            <format type="text">
                <processing>Full text analysis and task execution based on content</processing>
            </format>
            <format type="image">
                <processing>Visual analysis and implementation generation</processing>
            </format>
            <format type="code">
                <processing>Code analysis, modification, and reference tracking</processing>
            </format>
        </formats>
        <metadata>
            <field name="chunk_index">${args.chunkIndex}</field>
            <field name="total_chunks">${args.totalChunks}</field>
        </metadata>
        <chunk>${args.chunk.text}</chunk>
    </chunk_input>
    <rules>
        <primary_rules>
            Execute the task on current chunk content and generate deliverable output
            Each chunk analysis must be returned in markdown format
            Maintain consistent markdown headers and structure
            Work only with information available in current chunk
        </primary_rules>
        When processing a chunk, analyze the content and execute the task based solely on what's available
        Keep track of key findings from current chunk. Use snapshot of chunk data if it's required.
        For code chunks, maintain file context and keep file names in responses and chunk data of file.
        <output_format>
            <format>markdown</format>
            <structure>
                ## Chunk Analysis
                ### Metadata
                - Content type and source information
                - File names or references if applicable
                
                ### Key Findings
                - What was executed/implemented from the task based on current chunk
                
                ### Preserved Data
                - **MUST contain actual deliverables that execute the task on current chunk**
                - For diagram tasks: diagram code (PlantUML/Mermaid) for components in this chunk
                - For code tasks: working implementation based on this chunk
                - For documentation tasks: formatted documentation for content in this chunk
                - NOT summaries, NOT yaml lists, NOT abstracts
                - This is what the final agent will receive - make it complete and ready to merge with other chunks
            </structure>
        </output_format>
        <response_rules>
            Processing individual chunks:
            - Return analysis in markdown format
            - **CRITICAL**: In "Preserved Data" section, include actual task execution results based on current chunk
            - If task is to create diagram: generate diagram code for components found in this chunk
            - If task is to write code: generate actual code implementation based on this chunk
            - DO NOT just summarize - execute the task with available data
            - Generate deliverables that can be combined with other chunks' results later
            
            General rules:
            - Use markdown code blocks for all deliverables (code, diagrams, configs, etc.)
            - Remember: your output will be collected and sent to final agent as context
            - Make deliverables complete and ready to be merged by the final agent
            - Focus only on current chunk content - do not reference or wait for other chunks
        </response_rules>
    </rules>
    <examples>
        <example>
            <input>
                <chunk_number>1</chunk_number>
                <total_chunks>3</total_chunks>
                <content_type>configuration</content_type>
                <task>Generate environment configuration file</task>
                <data>
                Database: PostgreSQL on db.example.com:5432
                Redis: localhost:6379
                API Key: stored in AWS Secrets Manager
                </data>
            </input>
            <output>
                ```markdown
                ## Chunk Analysis
                ### Metadata
                - Type: Configuration
                - Task: Generate environment configuration file

                ### Key Findings
                - Generated database configuration properties
                - Generated Redis cache settings
                - Generated security configuration for AWS Secrets Manager

                ### Preserved Data
                ```properties
                # Database Configuration
                db.host=db.example.com
                db.port=5432
                db.driver=postgresql

                # Cache Configuration
                redis.host=localhost
                redis.port=6379

                # Security
                api.key.source=aws-secrets-manager
                ```
                ```
            </output>
        </example>
        <example>
            <input>
                <chunk_number>1</chunk_number>
                <total_chunks>3</total_chunks>
                <content_type>code</content_type>
                <data>
                    LoginService.java
                    @PostMapping("/login")
                    public String login(String username, String password) {
                    return authService.login(username, password);
                    }
                </data>
            </input>
            <output>
                ```markdown
                ## Chunk Analysis
                ### Metadata
                - Type: Java Code
                - File: LoginService.java

                ### Key Findings
                - Extracted login endpoint implementation
                - Preserved authentication service integration

                ### Preserved Data
                ```java
                @PostMapping("/login")
                public String login(String username, String password) {
                return authService.login(username, password);
                }
                ```
                ```
            </output>
        </example>
        <example>
            <input>
                <chunk_number>1</chunk_number>
                <total_chunks>1</total_chunks>
                <content_type>image</content_type>
                <data>[attached image product_card_design.png showing modern e-commerce product card]</data>
            </input>
            <output>
                ```markdown
                ## Chunk Analysis
                ### Metadata
                - Type: UI Design
                - File: product_card_design.png

                ### Key Findings
                - Implemented Product Card HTML structure
                - Generated responsive CSS with mobile breakpoints
                - Created complete component with image, title, price, and button

                ### Preserved Data
                ```html
                <div class="product-card">
                    <img class="product-image" src="product.jpg" alt="Product"/>
                    <div class="product-info">
                        <h3 class="product-title">Product Name</h3>
                        <p class="product-price">$99.99</p>
                        <button class="buy-button">Add to Cart</button>
                    </div>
                </div>
                ```

                ```css
                .product-card {
                display: flex;
                flex-direction: column;
                max-width: 300px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                border-radius: 8px;
                overflow: hidden;
                }
                @media (max-width: 768px) {
                .product-card {
                max-width: 100%;
                }
                }
                ```
                ```
            </output>
        </example>
        <example>
            <input>
                <chunk_number>1</chunk_number>
                <total_chunks>1</total_chunks>
                <content_type>code</content_type>
                <data>
                    UserService.java
                    public class UserService {
                    public void registerUser(User user) {
                    userRepository.save(user);
                    }
                    }
                </data>
            </input>
            <output>
                ```markdown
                ## Chunk Analysis
                ### Metadata
                - Type: Java Code
                - File: UserService.java

                ### Key Findings
                - Implemented validation logic in registerUser method
                - Added UserValidator integration with error handling
                - Enhanced service with validation checks before repository access

                ### Preserved Data
                ```java
                public class UserService {
                @Autowired
                private UserValidator validator;

                public void registerUser(User user) {
                ValidationResult result = validator.validate(user);
                if (!result.isValid()) {
                throw new ValidationException(result.getErrors());
                }
                userRepository.save(user);
                }
                }
                ```
                ```
            </output>
        </example>
        <example>
            <input>
                <chunk_number>1</chunk_number>
                <total_chunks>2</total_chunks>
                <content_type>architecture_documentation</content_type>
                <task>Create C4 diagram of the system architecture</task>
                <data>
                    System Architecture Documentation:
                    - Frontend: React SPA communicating via REST API
                    - Backend: Spring Boot microservices
                    - Database: PostgreSQL
                    - Cache: Redis
                    - Message Queue: RabbitMQ
                </data>
            </input>
            <output>
                ```markdown
                ## Chunk Analysis
                ### Metadata
                - Type: Architecture Documentation
                - Task: Create C4 diagram

                ### Key Findings
                - Generated C4 Context diagram with all system components
                - Implemented Frontend-Backend relationships with REST API
                - Added infrastructure components: PostgreSQL, Redis, RabbitMQ with connections

                ### Preserved Data
                **C4 Context Diagram:**
                ```plantuml
                @startuml
                !include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Context.puml

                Person(user, "User", "System user")
                System(frontend, "Frontend Application", "React SPA")
                System(backend, "Backend Services", "Spring Boot Microservices")
                SystemDb(database, "Database", "PostgreSQL")
                SystemDb(cache, "Cache", "Redis")
                SystemQueue(queue, "Message Queue", "RabbitMQ")

                Rel(user, frontend, "Uses", "HTTPS")
                Rel(frontend, backend, "Makes API calls", "REST/HTTPS")
                Rel(backend, database, "Reads/Writes", "JDBC")
                Rel(backend, cache, "Caches data", "Redis Protocol")
                Rel(backend, queue, "Publishes/Consumes messages", "AMQP")
                @enduml
                ```
                ```
            </output>
        </example>
    </examples>
</chunk_processing>
<#else>
<#if args.chunk??>
<additional_context>${args.chunk.text}</additional_context>
</#if>
</#if>