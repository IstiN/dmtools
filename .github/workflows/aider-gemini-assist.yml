name: Aider Code Assistant (Gemini)

on:
  workflow_dispatch:
    inputs:
      user_request:
        description: 'Your request for Aider'
        required: true
        type: string
      target_files:
        description: 'Files to include in context (comma-separated, optional)'
        required: false
        type: string
        default: ''
      model:
        description: 'Google Gemini model to use'
        required: false
        type: choice
        default: 'gemini/gemini-2.5-flash-preview-05-20'
        options:
          - gemini/gemini-2.5-flash-preview-05-20
          - gemini/gemini-1.5-pro-latest
          - gemini/gemini-1.5-pro-002
          - gemini/gemini-1.5-flash-latest
          - gemini/gemini-1.5-flash-002
          - gemini/gemini-1.0-pro-latest
      gemini_api_key_secret:
        description: 'GitHub secret name containing Gemini API key'
        required: false
        type: string
        default: 'GEMINI_API_KEY'
      max_tokens:
        description: 'Maximum tokens for context (Gemini 1.5 Pro supports up to 1M+)'
        required: false
        type: number
        default: 1000000

jobs:
  run-aider:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for better context

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Cache pip packages
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-aider-gemini-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-aider-gemini-
          ${{ runner.os }}-pip-

    - name: Cache Aider installation
      uses: actions/cache@v4
      with:
        path: |
          ~/.local/bin/aider
          ~/.local/share/aider
          ~/.cache/aider
          ~/.aider
        key: ${{ runner.os }}-aider-install-v085-${{ hashFiles('requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-aider-install-v085-
          ${{ runner.os }}-aider-install-
          ${{ runner.os }}-aider-

    - name: Cache Aider repo index
      uses: actions/cache@v4
      with:
        path: |
          .aider*
          .aider.repo.map
          .aider.tags
        key: ${{ runner.os }}-aider-repo-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-aider-repo-

    - name: Install Aider and dependencies
      run: |
        pip install --upgrade pip
        
        # Check if aider is already cached and working
        if command -v aider >/dev/null 2>&1 && aider --version >/dev/null 2>&1; then
          echo "‚úÖ Aider found in cache and working, skipping installation"
          aider --version
          INSTALL_AIDER=false
        else
          echo "üì¶ Aider not found in cache or not working, installing..."
          INSTALL_AIDER=true
        fi
        
        # Install Aider if needed
        if [ "$INSTALL_AIDER" = "true" ]; then
          echo "üîß Installing Aider using recommended method..."
          pip install aider-install
          aider-install
          
          # Verify new installation
          echo "üîç Verifying new Aider installation..."
          aider --version
          echo "‚úÖ Aider installation verified"
        fi
        
        # Install additional dependencies for Gemini models
        pip install google-generativeai

    - name: Create output directories and safe user input file
      env:
        USER_REQUEST_RAW: ${{ inputs.user_request }}
      run: |
        mkdir -p aider-outputs
        mkdir -p aider
        
        # User request is already base64 encoded, decode it directly to file
        echo "$USER_REQUEST_RAW" | base64 -d > aider-outputs/user-request.txt
        echo "üíæ User request decoded and saved to aider-outputs/user-request.txt"
        
        # Print the actual user request content for debugging  
        echo "üîç USER REQUEST CONTENT:"
        cat aider-outputs/user-request.txt
        echo "üîç END USER REQUEST"
        
        # No need to create analysis response file - we'll parse from logs

    - name: Validate Gemini API Key
      run: |
        # Check if the API key secret exists (indirect check)
        if [ -z "${{ secrets[inputs.gemini_api_key_secret] }}" ] && [ -z "${{ secrets.GEMINI_API_KEY }}" ]; then
          echo "ERROR: No Gemini API key found. Please set up GEMINI_API_KEY secret or specify custom secret name."
          exit 1
        fi
        echo "Gemini API key validation passed"

    - name: Run Aider with Gemini model
      env:
        # Try custom secret name first, fallback to default
        GEMINI_API_KEY: ${{ secrets[inputs.gemini_api_key_secret] || secrets.GEMINI_API_KEY }}
        GOOGLE_API_KEY: ${{ secrets[inputs.gemini_api_key_secret] || secrets.GEMINI_API_KEY }}
      run: |
        # Set timestamp for unique output file
        TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        OUTPUT_FILE="aider-outputs/response_${TIMESTAMP}.txt"
        
        # Prepare the command with optimization flags for large repos and context files
        AIDER_CMD="aider --model ${{ inputs.model }}"
        AIDER_CMD="$AIDER_CMD --max-chat-history-tokens ${{ inputs.max_tokens }}"
        AIDER_CMD="$AIDER_CMD --no-check-update --yes-always --no-stream"
        
        # Add only the user request file to context
        AIDER_CMD="$AIDER_CMD aider-outputs/user-request.txt"
        
        # Add additional target files if specified
        if [ -n "${{ inputs.target_files }}" ]; then
          IFS=',' read -ra FILES <<< "${{ inputs.target_files }}"
          for file in "${FILES[@]}"; do
            file=$(echo "$file" | xargs)  # Trim whitespace
            if [ -f "$file" ]; then
              AIDER_CMD="$AIDER_CMD $file"
            else
              echo "Warning: File '$file' not found" | tee -a "$OUTPUT_FILE"
            fi
          done
        fi
        
        # Prepare the message safely to avoid shell injection
        echo "=== PREPARING AIDER MESSAGE ===" | tee -a "$OUTPUT_FILE"
        
        # User request is already decoded above, just log it
        echo "User request already saved to aider-outputs/user-request.txt" | tee -a "$OUTPUT_FILE"
        
        # Execute and capture output
        echo "=== AIDER EXECUTION START ===" | tee -a "$OUTPUT_FILE"
        echo "Model: ${{ inputs.model }}" | tee -a "$OUTPUT_FILE"
        echo "Max Tokens: ${{ inputs.max_tokens }}" | tee -a "$OUTPUT_FILE"
        echo "Target Files: ${{ inputs.target_files || 'All files' }}" | tee -a "$OUTPUT_FILE"
        echo "Timestamp: $TIMESTAMP" | tee -a "$OUTPUT_FILE"
        echo "=== USER REQUEST CONTENT ===" | tee -a "$OUTPUT_FILE"
        cat aider-outputs/user-request.txt | tee -a "$OUTPUT_FILE"
        echo "=== END USER REQUEST ===" | tee -a "$OUTPUT_FILE"
        echo "=== AIDER RESPONSE ===" | tee -a "$OUTPUT_FILE"
        
        # Use the detailed assist-prompt.md as the message file
        echo "Using detailed assist-prompt.md as message file for better instructions" | tee -a "$OUTPUT_FILE"
        
        # Show the complete command that will be executed
        FINAL_CMD="$AIDER_CMD --message-file aider/assist-prompt.md"
        echo "=== AIDER COMMAND TO BE EXECUTED ===" | tee -a "$OUTPUT_FILE"
        echo "$FINAL_CMD" | tee -a "$OUTPUT_FILE"
        echo "=== END AIDER COMMAND ===" | tee -a "$OUTPUT_FILE"
        
        # Note: Not printing message file content to avoid extracting example tags
        
        # Run aider with detailed prompt file and context files
        eval "$FINAL_CMD" 2>&1 | tee -a "$OUTPUT_FILE"
        
        echo "=== AIDER EXECUTION END ===" | tee -a "$OUTPUT_FILE"
        
        # Parse AIDER_RESPONSE tags from console output
        echo "üîç Parsing AIDER_RESPONSE from console output..." | tee -a "$OUTPUT_FILE"
        
        # Extract content between <AIDER_RESPONSE> and </AIDER_RESPONSE> tags (excluding the tags)
        if grep -q "<AIDER_RESPONSE>" "$OUTPUT_FILE"; then
          echo "‚úÖ Found AIDER_RESPONSE tags in console output" | tee -a "$OUTPUT_FILE"
          
          # Extract only the content inside the tags, excluding the tags themselves
          # Look for the LAST occurrence to avoid example tags from prompt file
          EXTRACTED_RESPONSE=$(tac "$OUTPUT_FILE" | sed -n '/<\/AIDER_RESPONSE>/,/<AIDER_RESPONSE>/p' | tac | sed '1d;$d')
          RESPONSE_SIZE=$(echo "$EXTRACTED_RESPONSE" | wc -c)
          echo "‚úÖ Response extracted from console (size: $RESPONSE_SIZE bytes)" | tee -a "$OUTPUT_FILE"
          
          # Store response for summary
          echo "AIDER_RESPONSE<<EOF" >> $GITHUB_ENV
          echo "$EXTRACTED_RESPONSE" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
          echo "RESPONSE_FOUND=true" >> $GITHUB_ENV
          
          # Show preview for verification in logs
          echo "üîç First 5 lines of analysis response:" | tee -a "$OUTPUT_FILE"
          echo "$EXTRACTED_RESPONSE" | head -5 | tee -a "$OUTPUT_FILE"
          echo "üîç Last 3 lines of analysis response:" | tee -a "$OUTPUT_FILE"
          echo "$EXTRACTED_RESPONSE" | tail -3 | tee -a "$OUTPUT_FILE"
          
        else
          echo "‚ùå AIDER_RESPONSE tags not found in console output" | tee -a "$OUTPUT_FILE"
          echo "RESPONSE_FOUND=false" >> $GITHUB_ENV
          
          # Show what we have for debugging
          echo "üìÅ Console output search results:" | tee -a "$OUTPUT_FILE"
          grep -n "AIDER" "$OUTPUT_FILE" || echo "No AIDER tags found" | tee -a "$OUTPUT_FILE"
        fi
        
        # Save output file paths for artifact upload
        echo "OUTPUT_FILE=$OUTPUT_FILE" >> $GITHUB_ENV

    - name: Upload execution logs as artifact
      uses: actions/upload-artifact@v4
      with:
        name: aider-execution-logs-${{ github.run_number }}
        path: |
          aider-outputs/response_*.txt
          aider-outputs/user-request.txt
        retention-days: 7

    - name: Create dedicated response artifact
      run: |
        # Create dedicated response file for API consumption
        mkdir -p aider-outputs/api-response
        
        if [ "$RESPONSE_FOUND" = "true" ] && [ ! -z "$AIDER_RESPONSE" ]; then
          echo "‚úÖ Creating dedicated analysis response artifact for API consumption"
          
          # Create single markdown response file
          echo "# Analysis Response" > aider-outputs/api-response/response.md
          echo "" >> aider-outputs/api-response/response.md
          echo "$AIDER_RESPONSE" >> aider-outputs/api-response/response.md
          
          echo "üìù Response artifact created successfully"
          echo "Response size: $(wc -c < aider-outputs/api-response/response.md) bytes"
          
        else
          echo "‚ùå No analysis response found, creating error artifact"
          echo "# Analysis Response" > aider-outputs/api-response/response.md
          echo "" >> aider-outputs/api-response/response.md
          echo "**ERROR: Analysis Response Not Available**" >> aider-outputs/api-response/response.md
          echo "" >> aider-outputs/api-response/response.md
          echo "Could not find AIDER_RESPONSE tags in console output." >> aider-outputs/api-response/response.md
          echo "Please check the execution logs in artifacts for details." >> aider-outputs/api-response/response.md
        fi

    - name: Upload dedicated response artifact
      uses: actions/upload-artifact@v4
      with:
        name: response-${{ github.run_number }}
        path: aider-outputs/api-response/
        retention-days: 7

    - name: Display Aider response
      run: |
        # Display response or error information in step summary
        if [ "$RESPONSE_FOUND" = "true" ] && [ ! -z "$AIDER_RESPONSE" ]; then
          echo "## üéØ Aider Analysis Response" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "$AIDER_RESPONSE" >> $GITHUB_STEP_SUMMARY
        else
          echo "## ‚ùå Analysis Response Not Available" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Could not find AIDER_RESPONSE tags in console output." >> $GITHUB_STEP_SUMMARY
          echo "Please check the execution logs in artifacts for details." >> $GITHUB_STEP_SUMMARY
        fi
