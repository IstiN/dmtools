name: Aider Code Assistant (Gemini)

on:
  workflow_dispatch:
    inputs:
      user_request:
        description: 'Your request for Aider'
        required: true
        type: string
      target_files:
        description: 'Files to include in context (comma-separated, optional)'
        required: false
        type: string
        default: ''
      model:
        description: 'Google Gemini model to use'
        required: false
        type: choice
        default: 'gemini/gemini-2.5-flash-preview-05-20'
        options:
          - gemini/gemini-2.5-flash-preview-05-20
          - gemini/gemini-1.5-pro-latest
          - gemini/gemini-1.5-pro-002
          - gemini/gemini-1.5-flash-latest
          - gemini/gemini-1.5-flash-002
          - gemini/gemini-1.0-pro-latest
      gemini_api_key_secret:
        description: 'GitHub secret name containing Gemini API key'
        required: false
        type: string
        default: 'GEMINI_API_KEY'
      max_tokens:
        description: 'Maximum tokens for context (Gemini 1.5 Pro supports up to 1M+)'
        required: false
        type: number
        default: 1000000

jobs:
  run-aider:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for better context

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Cache pip packages
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-aider-gemini-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-aider-gemini-
          ${{ runner.os }}-pip-

    - name: Cache Aider installation
      uses: actions/cache@v4
      with:
        path: |
          ~/.local/bin/aider
          ~/.local/share/aider
          ~/.cache/aider
          ~/.aider
        key: ${{ runner.os }}-aider-install-v085-${{ hashFiles('requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-aider-install-v085-
          ${{ runner.os }}-aider-install-
          ${{ runner.os }}-aider-

    - name: Cache Aider repo index
      uses: actions/cache@v4
      with:
        path: |
          .aider*
          .aider.repo.map
          .aider.tags
        key: ${{ runner.os }}-aider-repo-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-aider-repo-

    - name: Install Aider and dependencies
      run: |
        pip install --upgrade pip
        
        # Check if aider is already cached and working
        if command -v aider >/dev/null 2>&1 && aider --version >/dev/null 2>&1; then
          echo "‚úÖ Aider found in cache and working, skipping installation"
          aider --version
          INSTALL_AIDER=false
        else
          echo "üì¶ Aider not found in cache or not working, installing..."
          INSTALL_AIDER=true
        fi
        
        # Install Aider if needed
        if [ "$INSTALL_AIDER" = "true" ]; then
          echo "üîß Installing Aider using recommended method..."
          pip install aider-install
          aider-install
          
          # Verify new installation
          echo "üîç Verifying new Aider installation..."
          aider --version
          echo "‚úÖ Aider installation verified"
        fi
        
        # Install additional dependencies for Gemini models
        pip install google-generativeai

    - name: Create output directories and safe user input file
      run: |
        mkdir -p aider-outputs
        mkdir -p aider
        
        # Write user input to file to prevent shell injection
        printf '%s\n' '${{ inputs.user_request }}' > aider-outputs/user_request.txt
        echo "üíæ Stored user request safely"

    - name: Validate Gemini API Key
      run: |
        # Check if the API key secret exists (indirect check)
        if [ -z "${{ secrets[inputs.gemini_api_key_secret] }}" ] && [ -z "${{ secrets.GEMINI_API_KEY }}" ]; then
          echo "ERROR: No Gemini API key found. Please set up GEMINI_API_KEY secret or specify custom secret name."
          exit 1
        fi
        echo "Gemini API key validation passed"

    - name: Run Aider with Gemini model
      env:
        # Try custom secret name first, fallback to default
        GEMINI_API_KEY: ${{ secrets[inputs.gemini_api_key_secret] || secrets.GEMINI_API_KEY }}
        GOOGLE_API_KEY: ${{ secrets[inputs.gemini_api_key_secret] || secrets.GEMINI_API_KEY }}
      run: |
        # Set timestamp for unique output file
        TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        OUTPUT_FILE="aider-outputs/response_${TIMESTAMP}.txt"
        
        # Prepare the command with optimization flags for large repos
        AIDER_CMD="aider --model ${{ inputs.model }}"
        AIDER_CMD="$AIDER_CMD --max-chat-history-tokens ${{ inputs.max_tokens }}"
        AIDER_CMD="$AIDER_CMD --subtree-only --no-check-update --no-suggest-shell-commands"
        
        # Add target files if specified
        if [ -n "${{ inputs.target_files }}" ]; then
          IFS=',' read -ra FILES <<< "${{ inputs.target_files }}"
          for file in "${FILES[@]}"; do
            file=$(echo "$file" | xargs)  # Trim whitespace
            if [ -f "$file" ]; then
              AIDER_CMD="$AIDER_CMD $file"
            else
              echo "Warning: File '$file' not found" | tee -a "$OUTPUT_FILE"
            fi
          done
        fi
        
        # Prepare the message safely to avoid shell injection
        echo "=== PREPARING AIDER MESSAGE ===" | tee -a "$OUTPUT_FILE"
        
        # Read user request from file and create safe message using printf to escape everything
        USER_REQUEST=$(cat aider-outputs/user_request.txt)
        
        # Build the message using printf to safely handle all special characters
        printf -v SAFE_MESSAGE 'Repository: %s. Request: %s. CRITICAL INSTRUCTION: DO NOT create any files. Instead, provide your COMPLETE response directly in your output, wrapped between these exact tags: <AIDER_RESPONSE_START> and <AIDER_RESPONSE_END>. Your response should be in markdown format and include all diagrams, explanations, and code examples. Make sure to include the complete answer between these tags. Focus on the core architecture and provide comprehensive details.' "${{ github.repository }}" "$USER_REQUEST"
        
        # Execute and capture output
        echo "=== AIDER EXECUTION START ===" | tee -a "$OUTPUT_FILE"
        echo "Model: ${{ inputs.model }}" | tee -a "$OUTPUT_FILE"
        echo "Max Tokens: ${{ inputs.max_tokens }}" | tee -a "$OUTPUT_FILE"
        echo "Request: ${{ inputs.user_request }}" | tee -a "$OUTPUT_FILE"
        echo "Target Files: ${{ inputs.target_files || 'All files' }}" | tee -a "$OUTPUT_FILE"
        echo "Timestamp: $TIMESTAMP" | tee -a "$OUTPUT_FILE"
        echo "=== AIDER RESPONSE ===" | tee -a "$OUTPUT_FILE"
        
        # Run aider with safe message and capture output
        eval "$AIDER_CMD --message \"\$SAFE_MESSAGE\"" 2>&1 | tee -a "$OUTPUT_FILE"
        
        echo "=== AIDER EXECUTION END ===" | tee -a "$OUTPUT_FILE"
        
        # Extract response from output using tags
        echo "üîç Extracting response from Aider output..." | tee -a "$OUTPUT_FILE"
        
        # Parse response between tags
        if grep -q "<AIDER_RESPONSE_START>" "$OUTPUT_FILE" && grep -q "<AIDER_RESPONSE_END>" "$OUTPUT_FILE"; then
          echo "‚úÖ Response tags found in output" | tee -a "$OUTPUT_FILE"
          
          # Extract content between tags to variable and file
          EXTRACTED_RESPONSE=$(sed -n '/<AIDER_RESPONSE_START>/,/<AIDER_RESPONSE_END>/p' "$OUTPUT_FILE" | sed '1d;$d')
          echo "$EXTRACTED_RESPONSE" > "aider-outputs/aider-response.md"
          
          # Verify extraction
          if [ -f "aider-outputs/aider-response.md" ] && [ -s "aider-outputs/aider-response.md" ]; then
            RESPONSE_SIZE=$(wc -c < "aider-outputs/aider-response.md")
            echo "‚úÖ Response extracted successfully (size: $RESPONSE_SIZE bytes)" | tee -a "$OUTPUT_FILE"
            
            # Store response for summary (escape for GitHub Actions)
            echo "AIDER_RESPONSE<<EOF" >> $GITHUB_ENV
            echo "$EXTRACTED_RESPONSE" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
            echo "RESPONSE_FOUND=true" >> $GITHUB_ENV
            
            # Show first and last few lines for verification in logs
            echo "üîç First 3 lines of extracted response:" | tee -a "$OUTPUT_FILE"
            echo "$EXTRACTED_RESPONSE" | head -3 | tee -a "$OUTPUT_FILE"
            echo "üîç Last 3 lines of extracted response:" | tee -a "$OUTPUT_FILE"
            echo "$EXTRACTED_RESPONSE" | tail -3 | tee -a "$OUTPUT_FILE"
          else
            echo "‚ùå Failed to extract response content" | tee -a "$OUTPUT_FILE"
            echo "RESPONSE_FOUND=false" >> $GITHUB_ENV
          fi
        else
          echo "‚ö†Ô∏è Response tags not found in output" | tee -a "$OUTPUT_FILE"
          echo "üîç Searching for partial tags..." | tee -a "$OUTPUT_FILE"
          grep -n "AIDER_RESPONSE" "$OUTPUT_FILE" | tee -a "$OUTPUT_FILE" || echo "No AIDER_RESPONSE tags found at all" | tee -a "$OUTPUT_FILE"
          echo "RESPONSE_FOUND=false" >> $GITHUB_ENV
        fi
        
        # Save output file paths for artifact upload
        echo "OUTPUT_FILE=$OUTPUT_FILE" >> $GITHUB_ENV

    - name: Upload execution logs as artifact
      uses: actions/upload-artifact@v4
      with:
        name: aider-execution-logs-${{ github.run_number }}
        path: |
          aider-outputs/response_*.txt
        retention-days: 7

    - name: Display Aider response
      run: |
        # Display only the raw Aider response content (no headers) - v2
        if [ "$RESPONSE_FOUND" = "true" ] && [ -f "aider-outputs/aider-response.md" ]; then
          echo "$AIDER_RESPONSE" >> $GITHUB_STEP_SUMMARY
        else
          echo "Response extraction failed - check execution logs in artifacts" >> $GITHUB_STEP_SUMMARY
        fi
