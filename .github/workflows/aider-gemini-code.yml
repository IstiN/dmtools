# Aider Code Implementation with PR Creation
name: Aider Two-Phase Implementation

on:
  workflow_dispatch:
    inputs:
      user_request:
        description: 'Your coding request for Aider (must include DMC-XXX ticket number)'
        required: true
        type: string
      target_files:
        description: 'Files to include in context (comma-separated, optional)'
        required: false
        type: string
        default: ''
      model:
        description: 'Google Gemini model to use'
        required: false
        type: choice
        default: 'gemini/gemini-2.5-flash-preview-05-20'
        options:
          - gemini/gemini-2.5-flash-preview-05-20
          - gemini/gemini-1.5-pro-latest
          - gemini/gemini-1.5-pro-002
          - gemini/gemini-1.5-flash-latest
          - gemini/gemini-1.5-flash-002
          - gemini/gemini-1.0-pro-latest
      gemini_api_key_secret:
        description: 'GitHub secret name containing Gemini API key'
        required: false
        type: string
        default: 'GEMINI_API_KEY'
      max_tokens:
        description: 'Maximum tokens for context (Gemini 1.5 Pro supports up to 1M+)'
        required: false
        type: number
        default: 1000000

      pr_title:
        description: 'Pull request title (auto-generated if empty)'
        required: false
        type: string
        default: ''
      pr_base_branch:
        description: 'Base branch for the pull request'
        required: false
        type: string
        default: 'main'

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  implement-code:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for better context
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Phase 1 - File Discovery and Analysis
      id: aider_discovery
      uses: ./.github/actions/aider-setup
      with:
        user_request: ${{ inputs.user_request }}
        model: ${{ inputs.model }}
        gemini_api_key: ${{ secrets[inputs.gemini_api_key_secret] || secrets.GEMINI_API_KEY }}
        max_tokens: ${{ inputs.max_tokens }}
        prompt_file: 'aider/discovery-prompt.md'
        mode: 'analysis'

    - name: Ensure discovery results are available for implementation
      run: |
        # Check if affected-files.json exists from discovery phase
        if [ -f "aider-outputs/affected-files.json" ]; then
          echo "‚úÖ Discovery JSON found, proceeding with implementation"
          echo "üìã Discovery file contents:"
          cat aider-outputs/affected-files.json
        else
          echo "‚ùå No discovery JSON found from Phase 1"
          echo "üìÅ Available files in aider-outputs:"
          ls -la aider-outputs/ || echo "No aider-outputs directory"
          
          # Create a fallback discovery file if none exists
          echo "üîß Creating fallback discovery structure"
          mkdir -p aider-outputs
          echo '{
            "ticket_number": "UNKNOWN",
            "request_summary": "Fallback - manual file discovery needed",
            "affected_files": {
              "to_modify": [],
              "to_create": [],
              "to_reference": [],
              "tests_needed": []
            },
            "dependencies": [],
            "implementation_notes": ["Discovery phase did not complete successfully"]
          }' > aider-outputs/affected-files.json
        fi

    - name: Phase 2 - Implementation using discovered files
      id: aider_run
      uses: ./.github/actions/aider-setup
      with:
        user_request: ${{ inputs.user_request }}
        target_files: ${{ inputs.target_files }}
        model: ${{ inputs.model }}
        gemini_api_key: ${{ secrets[inputs.gemini_api_key_secret] || secrets.GEMINI_API_KEY }}
        max_tokens: ${{ inputs.max_tokens }}
        prompt_file: 'aider/implementation-prompt.md'
        mode: 'coding'

    - name: Upload execution logs as artifact
      uses: actions/upload-artifact@v4
      with:
        name: aider-coding-logs-${{ github.run_number }}
        path: |
          aider-outputs/response_*.txt
          aider-outputs/user-request.txt
          aider-outputs/affected-files*.json
        retention-days: 7

    - name: Create implementation summary artifact
      env:
        AIDER_RESPONSE: ${{ steps.aider_run.outputs.aider_response }}
      run: |
        # Create dedicated summary file for PR description
        mkdir -p aider-outputs/pr-summary
        
        if [ "${{ steps.aider_run.outputs.response_found }}" = "true" ] && [ ! -z "$AIDER_RESPONSE" ]; then
          echo "‚úÖ Creating implementation summary for PR"
          
          # Save the implementation summary safely using environment variable to avoid shell injection
          echo "$AIDER_RESPONSE" > aider-outputs/pr-summary/implementation-summary.md
          
          echo "üìù Implementation summary created successfully"
          echo "Summary size: $(wc -c < aider-outputs/pr-summary/implementation-summary.md) bytes"
          
        else
          echo "‚ùå No implementation summary found, creating error summary"
          echo "# Implementation Summary" > aider-outputs/pr-summary/implementation-summary.md
          echo "" >> aider-outputs/pr-summary/implementation-summary.md
          echo "**ERROR: Implementation Not Completed**" >> aider-outputs/pr-summary/implementation-summary.md
          echo "" >> aider-outputs/pr-summary/implementation-summary.md
          echo "Aider did not complete the implementation successfully." >> aider-outputs/pr-summary/implementation-summary.md
          echo "Please check the execution logs for details." >> aider-outputs/pr-summary/implementation-summary.md
        fi

    - name: Upload implementation summary artifact
      uses: actions/upload-artifact@v4
      with:
        name: implementation-summary-${{ github.run_number }}
        path: aider-outputs/pr-summary/
        retention-days: 7

    - name: Configure Git for Aider operations
      run: |
        # Configure git user for Aider's commits
        git config user.name "aider[bot]"
        git config user.email "aider-bot@ai-assistant.local"
        echo "‚úÖ Git configured for Aider operations"

    - name: Check for new branches created by Aider
      id: check_branches
      run: |
        # Check if Aider created any new branches
        CURRENT_BRANCH=$(git branch --show-current)
        echo "Current branch: $CURRENT_BRANCH"
        
        # Log what Aider modified
        echo "=== CHECKING WHAT AIDER MODIFIED ==="
        echo "üìã Git status after Aider execution:"
        git status --porcelain || echo "No changes detected"
        
        echo "üìã Modified files:"
        git diff --name-only || echo "No modified files"
        
        echo "üìã Staged files:"
        git diff --cached --name-only || echo "No staged files"
        
        echo "üìã Untracked files:"
        git ls-files --others --exclude-standard || echo "No untracked files"
        
        if [ "$CURRENT_BRANCH" != "main" ] && [ "$CURRENT_BRANCH" != "${{ inputs.pr_base_branch }}" ]; then
          echo "‚úÖ Aider created a new branch: $CURRENT_BRANCH"
          echo "new_branch=$CURRENT_BRANCH" >> $GITHUB_OUTPUT
          echo "has_new_branch=true" >> $GITHUB_OUTPUT
          echo "BRANCH_NAME=$CURRENT_BRANCH" >> $GITHUB_ENV
          
          # Check if there are commits on this branch
          COMMIT_COUNT=$(git rev-list --count HEAD ^origin/${{ inputs.pr_base_branch }} 2>/dev/null || echo "0")
          echo "Commits on new branch: $COMMIT_COUNT"
          echo "commit_count=$COMMIT_COUNT" >> $GITHUB_OUTPUT
          
          if [ "$COMMIT_COUNT" -gt 0 ]; then
            echo "has_commits=true" >> $GITHUB_OUTPUT
            echo "CHANGES_STATUS=has_changes" >> $GITHUB_ENV
          else
            echo "has_commits=false" >> $GITHUB_OUTPUT
            echo "CHANGES_STATUS=no_changes" >> $GITHUB_ENV
          fi
        else
          echo "‚ÑπÔ∏è No new branch created by Aider, checking for changes on current branch"
          echo "has_new_branch=false" >> $GITHUB_OUTPUT
          
          # Check if there are uncommitted changes that we need to handle
          if ! git diff --quiet || ! git diff --cached --quiet || [ -n "$(git ls-files --others --exclude-standard)" ]; then
            echo "üìã Found uncommitted changes, will create fallback branch"
            echo "has_uncommitted_changes=true" >> $GITHUB_OUTPUT
            echo "CHANGES_STATUS=has_changes" >> $GITHUB_ENV
          else
            echo "has_uncommitted_changes=false" >> $GITHUB_OUTPUT
            echo "has_commits=false" >> $GITHUB_OUTPUT
            echo "CHANGES_STATUS=no_changes" >> $GITHUB_ENV
          fi
        fi

    - name: Push feature branch created by Aider
      if: steps.check_branches.outputs.has_new_branch == 'true' && steps.check_branches.outputs.has_commits == 'true'
      run: |
        BRANCH_NAME="${{ steps.check_branches.outputs.new_branch }}"
        
        # Push the branch created by Aider
        git push origin "$BRANCH_NAME"
        echo "‚úÖ Aider's feature branch pushed successfully: $BRANCH_NAME"

    - name: Create and push fallback branch for uncommitted changes
      if: steps.check_branches.outputs.has_new_branch == 'false' && steps.check_branches.outputs.has_uncommitted_changes == 'true'
      id: fallback_branch
      run: |
        echo "üîÑ Creating fallback branch since Aider didn't create one"
        
        # Generate PR title for branch name
        if [ -n "${{ inputs.pr_title }}" ]; then
          PR_TITLE="${{ inputs.pr_title }}"
        else
          USER_REQUEST_DECODED=$(echo "${{ inputs.user_request }}" | base64 -d)
          PR_TITLE="$(echo "$USER_REQUEST_DECODED" | head -c 80)"
        fi
        
        # Generate unique branch name with timestamp and run ID to avoid conflicts
        TIMESTAMP=$(date +%Y%m%d-%H%M%S)
        RUN_ID="${{ github.run_id }}"
        # Clean branch name: remove newlines, convert to lowercase, replace spaces/special chars with dashes
        BRANCH_BASE="$(echo "$PR_TITLE" | tr '\n\r' ' ' | head -c 30 | tr ' ' '-' | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]//g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')"
        BRANCH_NAME="aider/${BRANCH_BASE}-${TIMESTAMP}-${RUN_ID}"
        
        echo "üìã Creating unique fallback branch: $BRANCH_NAME"
        
        # Create and switch to new branch
        git checkout -b "$BRANCH_NAME"
        
        # Add all changes
        git add .
        
        # Create commit with user request info
        USER_REQUEST_DECODED=$(echo "${{ inputs.user_request }}" | base64 -d)
        COMMIT_MSG="Aider implementation: $(echo "$USER_REQUEST_DECODED" | head -c 60) - Implemented via Aider AI assistant using ${{ inputs.model }} (Fallback commit created by workflow) - Request: $USER_REQUEST_DECODED - Co-authored-by: Aider <aider@ai-assistant>"
        
        git commit -m "$COMMIT_MSG"
        echo "‚úÖ Fallback branch and commit created successfully"
        
        # Push the fallback branch with error handling
        if git push origin "$BRANCH_NAME"; then
          echo "‚úÖ Fallback feature branch pushed successfully: $BRANCH_NAME"
        else
          echo "‚ùå Push failed, trying with force push (lease)"
          if git push --force-with-lease origin "$BRANCH_NAME"; then
            echo "‚úÖ Fallback feature branch force-pushed successfully: $BRANCH_NAME"
          else
            echo "‚ùå Force push also failed, creating alternative branch name"
            # Generate alternative branch name with additional uniqueness
            ALT_BRANCH_NAME="${BRANCH_NAME}-alt-$(date +%s)"
            git checkout -b "$ALT_BRANCH_NAME"
            git push origin "$ALT_BRANCH_NAME"
            BRANCH_NAME="$ALT_BRANCH_NAME"
            echo "‚úÖ Alternative fallback branch pushed successfully: $BRANCH_NAME"
          fi
        fi
        
        # Set outputs for next steps
        echo "new_branch=$BRANCH_NAME" >> $GITHUB_OUTPUT
        echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV

    - name: Generate PR title
      id: generate_pr_title
      if: env.CHANGES_STATUS == 'has_changes'
      run: |
        # Generate PR title if not provided
        if [ -n "${{ inputs.pr_title }}" ]; then
          PR_TITLE="${{ inputs.pr_title }}"
        else
          USER_REQUEST_DECODED=$(echo "${{ inputs.user_request }}" | base64 -d)
          PR_TITLE="Aider: $(echo "$USER_REQUEST_DECODED" | head -c 80)"
        fi
        
        echo "pr_title=$PR_TITLE" >> $GITHUB_OUTPUT
        echo "üìã Generated PR title: $PR_TITLE"

    - name: Create Pull Request
      if: env.CHANGES_STATUS == 'has_changes'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Determine which branch to use
        if [ "${{ steps.check_branches.outputs.has_new_branch }}" = "true" ]; then
          BRANCH_NAME="${{ steps.check_branches.outputs.new_branch }}"
          echo "üìã Using Aider-created branch: $BRANCH_NAME"
        else
          BRANCH_NAME="${{ steps.fallback_branch.outputs.new_branch }}"
          echo "üìã Using fallback branch: $BRANCH_NAME"
        fi
        
        PR_TITLE="${{ steps.generate_pr_title.outputs.pr_title }}"
        BASE_BRANCH="${{ inputs.pr_base_branch }}"
        
        # Get the implementation summary for PR body
        if [ -f "aider-outputs/pr-summary/implementation-summary.md" ]; then
          PR_BODY_FILE="aider-outputs/pr-summary/implementation-summary.md"
        else
          # Fallback to basic description
          echo "# Aider Implementation" > /tmp/pr-body.md
          echo "" >> /tmp/pr-body.md
          echo "This PR was created automatically by Aider AI assistant." >> /tmp/pr-body.md
          echo "" >> /tmp/pr-body.md
          echo "## Original Request" >> /tmp/pr-body.md
          echo "" >> /tmp/pr-body.md
          echo "${{ inputs.user_request }}" | base64 -d >> /tmp/pr-body.md
          echo "" >> /tmp/pr-body.md
          echo "## Implementation Details" >> /tmp/pr-body.md
          echo "" >> /tmp/pr-body.md
          echo "Changes were implemented using ${{ inputs.model }} model." >> /tmp/pr-body.md
          PR_BODY_FILE="/tmp/pr-body.md"
        fi
        
        # Create the pull request using GitHub CLI
        gh pr create \
          --title "$PR_TITLE" \
          --body-file "$PR_BODY_FILE" \
          --base "$BASE_BRANCH" \
          --head "$BRANCH_NAME" \
          --label "aider-generated" \
          --label "automated-pr"
        
        # Get the PR URL and number
        PR_URL=$(gh pr view "$BRANCH_NAME" --json url --jq '.url')
        PR_NUMBER=$(gh pr view "$BRANCH_NAME" --json number --jq '.number')
        
        echo "‚úÖ Pull Request created successfully!"
        echo "üîó PR URL: $PR_URL"
        echo "üìã PR Number: #$PR_NUMBER"
        
        # Store for summary
        echo "PR_URL=$PR_URL" >> $GITHUB_ENV
        echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_ENV

    - name: Display execution summary
      env:
        AIDER_RESPONSE: ${{ steps.aider_run.outputs.aider_response }}
        DISCOVERY_RESPONSE: ${{ steps.aider_discovery.outputs.aider_response }}
      run: |
        # Display comprehensive summary
        echo "## üöÄ Aider Two-Phase Implementation Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Show request details
        echo "### üìã Request Details" >> $GITHUB_STEP_SUMMARY
        echo "- **Model**: ${{ inputs.model }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Max Tokens**: ${{ inputs.max_tokens }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Target Files**: ${{ inputs.target_files || 'All files' }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Show original request
        echo "### üìù Original Request" >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY
        echo "${{ inputs.user_request }}" | base64 -d >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Show discovery phase results
        if [ "${{ steps.aider_discovery.outputs.response_found }}" = "true" ]; then
          echo "### üîç Phase 1: Discovery Analysis" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "$DISCOVERY_RESPONSE" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
        fi
        
        # Show implementation results
        if [ "$CHANGES_STATUS" = "has_changes" ]; then
          echo "### ‚úÖ Implementation Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: Implementation completed with changes" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: $BRANCH_NAME" >> $GITHUB_STEP_SUMMARY
          echo "- **Pull Request**: [#$PR_NUMBER]($PR_URL)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Include Aider's summary if available
          if [ "${{ steps.aider_run.outputs.response_found }}" = "true" ]; then
            echo "### üìä Phase 2: Implementation Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "$AIDER_RESPONSE" >> $GITHUB_STEP_SUMMARY
          fi
        else
          echo "### ‚ÑπÔ∏è No Changes Made" >> $GITHUB_STEP_SUMMARY
          echo "Aider completed execution but no code changes were necessary or made." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.aider_run.outputs.response_found }}" = "true" ]; then
            echo "### üìù Aider Response" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "$AIDER_RESPONSE" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ‚ùå Implementation Error" >> $GITHUB_STEP_SUMMARY
            echo "No valid response received from Aider. Check execution logs for details." >> $GITHUB_STEP_SUMMARY
          fi
        fi
