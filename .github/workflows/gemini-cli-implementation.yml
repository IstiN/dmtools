# Gemini CLI Implementation
name: Gemini CLI Implementation

on:
  workflow_dispatch:
    inputs:
      user_request:
        description: 'Your coding request for Gemini CLI'
        required: true
        type: string
      model:
        description: 'Gemini model to use'
        required: false
        type: choice
        default: 'gemini-2.5-flash-preview-05-20'
        options:
          - gemini-2.0-flash-exp
          - gemini-1.5-pro-latest
          - gemini-1.5-flash-latest
          - gemini-1.0-pro-latest
          - gemini-2.5-flash-preview-05-20
          - gemini-2.5-pro-latest


      pr_base_branch:
        description: 'Base branch for the pull request'
        required: false
        type: string
        default: 'main'
      enable_debug_logging:
        description: 'Enable comprehensive debug logging for Gemini CLI'
        required: false
        type: boolean
        default: true

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  implement-code:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for better context

    - name: Setup DMTools Environment
      uses: ./.github/actions/setup-environment
      with:
        cache-key-suffix: '-gemini'

    - name: Setup Gemini CLI MCP Configuration
      run: |
        echo "üîß Setting up Gemini CLI MCP configuration..."
        
        # Create .gemini directory
        mkdir -p ~/.gemini
        
        # Create MCP settings.json configuration
        cat > ~/.gemini/settings.json << 'EOF'
        {
          "mcpServers": {
            "dmtools-prod": {
              "command": "node",
              "args": ["/usr/local/lib/node_modules/@modelcontextprotocol/server-filesystem/dist/index.js", "/tmp"],
              "transport": {
                "type": "stdio"
              }
            }
          }
        }
        EOF
        
        echo "‚úÖ MCP configuration created"
        echo "üìã Configuration content:"
        cat ~/.gemini/settings.json

    - name: Prepare request for Gemini CLI
      id: prepare_request
      run: |
        ./cli_agents/scripts/prepare-user-request.sh "${{ github.event.inputs.user_request }}" "outputs"

    - name: Setup Gemini CLI environment
      run: |
        ./cli_agents/scripts/setup-cli-env.sh "gemini" "${{ github.event.inputs.model }}" "${{ secrets.GEMINI_API_KEY }}"

    - name: Generate PR details using direct Gemini API
      id: generate_pr_details
      run: |
        echo "üîß Generating PR details using direct Gemini API..."
        
        # Export environment variables for API call
        export GEMINI_API_KEY="${{ secrets.GEMINI_API_KEY }}"
        
        # Use our direct API script for PR generation
        if ./cli_agents/scripts/generate_pr_notes.sh "outputs/user-request.txt" "outputs"; then
          echo "‚úÖ PR details generation successful"
          
          # Verify pr_notes.json was created and is valid
          if [ -f "outputs/pr_notes.json" ]; then
            echo "‚úÖ Found pr_notes.json file"
            echo "üìã PR notes content:"
            cat outputs/pr_notes.json
            
            # Validate JSON format
            if command -v jq >/dev/null 2>&1; then
              if jq empty outputs/pr_notes.json 2>/dev/null; then
                echo "‚úÖ JSON validation passed"
              else
                echo "‚ùå ERROR: Invalid JSON format in pr_notes.json"
                exit 1
              fi
            fi
          else
            echo "‚ùå ERROR: pr_notes.json file was not created"
            exit 1
          fi
        else
          echo "‚ùå ERROR: PR generation failed"
          exit 1
        fi



    - name: Implementation using Gemini CLI
      id: gemini_implementation
      run: |
        echo "üöÄ Starting Gemini CLI Implementation"
        
        # Export environment variables for Gemini CLI
        export GEMINI_API_KEY="${{ secrets.GEMINI_API_KEY }}"
        
        # Configure debug logging based on input parameter
        if [ "${{ inputs.enable_debug_logging }}" = "true" ]; then
          echo "üîç Debug logging ENABLED - comprehensive output will be shown"
          # Based on Gemini CLI source code investigation:
          export DEBUG=1                              # Main debug flag
          export DEBUG_MODE=1                         # Alternative debug mode
          export DEBUG="gemini*,@google/gemini-cli*"  # Namespace-specific debug
          export NODE_OPTIONS="--trace-warnings --max-old-space-size=8192"
          export GEMINI_CLI_VERBOSE=true
          export GEMINI_CLI_LOG_LEVEL=debug
          export GEMINI_DEBUG_ENABLED=true
        else
          echo "üîá Debug logging DISABLED - minimal output will be shown"
          export NODE_OPTIONS="--max-old-space-size=8192"
          export GEMINI_DEBUG_ENABLED=false
        fi
        
        echo "üîç Debug: Checking Gemini CLI installation..."
        which gemini || echo "‚ùå Gemini CLI not found in PATH"
        gemini --version || echo "‚ùå Failed to get Gemini CLI version"
        
        if [ "${{ inputs.enable_debug_logging }}" = "true" ]; then
          echo "üîç Debug: Checking MCP server configuration..."
          echo "- Gemini settings directory:"
          ls -la ~/.gemini/ 2>/dev/null || echo "‚ùå No ~/.gemini directory found"
          echo "- MCP settings file:"
          cat ~/.gemini/settings.json 2>/dev/null || echo "‚ùå No settings.json found"
          
          echo "üîç Debug: Testing MCP server connectivity..."
          echo "This will help identify MCP connection issues when they occur."
        fi
        
        if [ "${{ inputs.enable_debug_logging }}" = "true" ]; then
          echo "üîç Debug: Environment variables:"
          echo "- GEMINI_API_KEY: ${GEMINI_API_KEY:0:10}..."
          echo "- PWD: $(pwd)"
          echo "- User request file exists: $(test -f outputs/user-request.txt && echo 'YES' || echo 'NO')"
          
          echo "üîç Debug: Contents of user request:"
          cat outputs/user-request.txt || echo "‚ùå Could not read user request file"
          
          echo "üîç Debug: Environment summary:"
          echo "- Node version: $(node --version)"
          echo "- NPM version: $(npm --version)"
          echo "- Available memory: $(free -h | grep Mem || echo 'Memory info not available')"
          echo "- Disk space: $(df -h . | tail -1)"
        else
          echo "üìã Basic info: User request file exists: $(test -f outputs/user-request.txt && echo 'YES' || echo 'NO')"
        fi
        
        # Run implementation using our simplified script with comprehensive logging
        echo "üöÄ Executing run-gemini.sh script with full logging..."
        echo "üìã Script command: ./cli_agents/scripts/run-gemini.sh implementation outputs/user-request.txt"
        
        # Capture both stdout and stderr with timestamps and timeout protection
        set -x  # Enable command tracing
        (
          echo "=== GEMINI CLI EXECUTION START: $(date) ==="
          echo "üïê Timeout set to 25 minutes to prevent infinite loops"
          
          # Use timeout with kill signal after grace period
          timeout --signal=TERM --kill-after=60s 25m ./cli_agents/scripts/run-gemini.sh "implementation" "outputs/user-request.txt" 2>&1 | while IFS= read -r line; do
            echo "[$(date '+%H:%M:%S')] $line"
            
            # Always check for critical error patterns
            if [[ "$line" == *"MaxListenersExceededWarning"* ]]; then
              echo "[$(date '+%H:%M:%S')] ‚ö†Ô∏è WARNING: Detected potential memory leak warning"
            fi
            if [[ "$line" == *"Error executing tool"* ]]; then
              echo "[$(date '+%H:%M:%S')] ‚ö†Ô∏è WARNING: Detected tool execution error"
            fi
            
            # Additional debug patterns only when debug logging is enabled
            if [ "${{ inputs.enable_debug_logging }}" = "true" ]; then
              # Check for MCP connection patterns (based on CLI source investigation)
              if [[ "$line" == *"Attempting to connect to"* ]]; then
                echo "[$(date '+%H:%M:%S')] üîç MCP: Connection attempt detected"
              fi
              if [[ "$line" == *"Cannot connect to"*"server may be down"* ]]; then
                echo "[$(date '+%H:%M:%S')] üö® MCP: Connection failed"
              fi
              if [[ "$line" == *"Connected to"*"server"* ]]; then
                echo "[$(date '+%H:%M:%S')] ‚úÖ MCP: Connection successful"
              fi
              
              # Debug mode confirmations
              if [[ "$line" == *"Found readable global GEMINI.md"* ]] || [[ "$line" == *"Searching for GEMINI.md"* ]]; then
                echo "[$(date '+%H:%M:%S')] üîç DEBUG: Memory discovery active"
              fi
            fi
          done
          
          TIMEOUT_EXIT=$?
          echo "=== GEMINI CLI EXECUTION END: $(date) ==="
          if [ $TIMEOUT_EXIT -eq 124 ]; then
            echo "‚ùå TIMEOUT: Gemini CLI execution exceeded 25 minutes - likely in infinite loop"
          elif [ $TIMEOUT_EXIT -eq 137 ]; then
            echo "‚ùå KILLED: Gemini CLI process was forcefully terminated"
          fi
          exit $TIMEOUT_EXIT
        ) | tee outputs/gemini-execution.log
        IMPLEMENTATION_EXIT_CODE=${PIPESTATUS[0]}
        set +x  # Disable command tracing
        
        echo "üìã Script exit code: $IMPLEMENTATION_EXIT_CODE"
        
        # Check for log files and show summary
        echo "üîç Debug: Checking for output files..."
        ls -la outputs/ || echo "‚ùå No outputs directory found"
        
        echo "üìã Gemini execution log summary (last 50 lines):"
        if [ -f "outputs/gemini-execution.log" ]; then
          tail -50 outputs/gemini-execution.log
        else
          echo "‚ùå No gemini-execution.log found"
        fi
        
        echo "üîç Debug: Checking for response.md file..."
        if [ -f "outputs/response.md" ]; then
          echo "‚úÖ Found response.md ($(wc -c < outputs/response.md) bytes)"
          echo "üìã Response.md preview (first 10 lines):"
          head -10 outputs/response.md
        else
          echo "‚ùå response.md file is missing!"
          echo "üîç Available files in outputs directory:"
          ls -la outputs/ || echo "‚ùå No outputs directory found"
          
          echo "üîç Looking for any *.md files in outputs:"
          find outputs/ -name "*.md" 2>/dev/null || echo "‚ùå No .md files found"
        fi
        
        # Check if implementation was successful
        if [ $IMPLEMENTATION_EXIT_CODE -eq 0 ]; then
          echo "‚úÖ Implementation completed successfully"
          if [ -f "outputs/response.md" ]; then
            echo "üìÑ Found response.md file"
            IMPLEMENTATION_RESPONSE=$(cat outputs/response.md)
            echo "gemini_response<<EOF" >> $GITHUB_OUTPUT
            echo "$IMPLEMENTATION_RESPONSE" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è No response.md file found"
            echo "gemini_response=Implementation completed but no response file found" >> $GITHUB_OUTPUT
          fi
        else
          echo "‚ùå Implementation failed with exit code $IMPLEMENTATION_EXIT_CODE"
          
          # Determine failure reason
          if [ $IMPLEMENTATION_EXIT_CODE -eq 124 ]; then
            FAILURE_REASON="TIMEOUT - Execution exceeded 25 minutes (likely infinite loop)"
          elif [ $IMPLEMENTATION_EXIT_CODE -eq 137 ]; then
            FAILURE_REASON="KILLED - Process was forcefully terminated"
          else
            FAILURE_REASON="FAILED with exit code $IMPLEMENTATION_EXIT_CODE"
          fi
          
          echo "üîç Failure reason: $FAILURE_REASON"
          
          # Try to get error details from log files
          if [ -f "outputs/response-log_"*".txt" ]; then
            echo "üìã Error log content (last 100 lines):"
            tail -100 outputs/response-log_*.txt
          fi
          
          # Show execution log for timeout cases
          if [ $IMPLEMENTATION_EXIT_CODE -eq 124 ] || [ $IMPLEMENTATION_EXIT_CODE -eq 137 ]; then
            echo "üìã Last 100 lines of execution log to analyze loop patterns:"
            if [ -f "outputs/gemini-execution.log" ]; then
              tail -100 outputs/gemini-execution.log
            fi
          fi
          
          echo "gemini_response=Implementation $FAILURE_REASON" >> $GITHUB_OUTPUT
        fi

    - name: Create implementation summary and handle Git workflow
      env:
        IMPLEMENTATION_RESPONSE: ${{ steps.gemini_implementation.outputs.gemini_response }}
      run: |
        # Save implementation summary for PR description
        mkdir -p outputs/pr-summary
        echo "$IMPLEMENTATION_RESPONSE" > outputs/pr-summary/implementation-summary.md
        echo "üìù Implementation summary saved"
        
        # Read PR details from generated pr_notes.json (guaranteed to exist)
        echo "üìã Reading PR details from pr_notes.json..."
        
        # Extract values using jq if available, otherwise use grep/sed
        if command -v jq >/dev/null 2>&1; then
          FULL_BRANCH_NAME=$(cat outputs/pr_notes.json | jq -r '.branchName')
          COMMIT_MESSAGE=$(cat outputs/pr_notes.json | jq -r '.commitMessage' | tr '\n' ' ')
          PR_TITLE=$(cat outputs/pr_notes.json | jq -r '.pullRequestTitle')
        else
          # Fallback parsing without jq
          FULL_BRANCH_NAME=$(grep '"branchName"' outputs/pr_notes.json | sed 's/.*"branchName"[^"]*"\([^"]*\)".*/\1/' | head -1)
          COMMIT_MESSAGE=$(grep '"commitMessage"' outputs/pr_notes.json | sed 's/.*"commitMessage"[^"]*"\([^"]*\)".*/\1/' | head -1 | tr '\n' ' ')
          PR_TITLE=$(grep '"pullRequestTitle"' outputs/pr_notes.json | sed 's/.*"pullRequestTitle"[^"]*"\([^"]*\)".*/\1/' | head -1)
        fi
        
        # Parse branch name to extract ticket and prefix (e.g., "api/DMC-413" -> prefix="api", ticket="DMC-413")
        if [[ "$FULL_BRANCH_NAME" =~ ^([^/]+)/(.+)$ ]]; then
          BRANCH_PREFIX="${BASH_REMATCH[1]}"
          TICKET_NUMBER="${BASH_REMATCH[2]}"
        else
          # Fallback: try to extract DMC-XXX pattern
          TICKET_NUMBER=$(echo "$FULL_BRANCH_NAME" | grep -o 'DMC-[0-9]\+' | head -1)
          BRANCH_PREFIX="core"  # Default prefix
        fi
        
        # Clean up commit message - remove excessive whitespace and truncate if too long
        COMMIT_MESSAGE=$(echo "$COMMIT_MESSAGE" | sed 's/  */ /g' | cut -c1-200)
        
        echo "üìã Extracted PR details:"
        echo "- Full Branch Name: $FULL_BRANCH_NAME"
        echo "- Branch Prefix: $BRANCH_PREFIX"
        echo "- Ticket Number: $TICKET_NUMBER"
        echo "- Commit: $COMMIT_MESSAGE"
        echo "- PR Title: $PR_TITLE"
        
        # Debug the parameters before calling git workflow
        echo "üîç Git workflow parameters:"
        echo "- TICKET_NUMBER: '$TICKET_NUMBER'"
        echo "- COMMIT_MESSAGE: '$COMMIT_MESSAGE'"
        echo "- PR_TITLE: '$PR_TITLE'"
        echo "- BRANCH_PREFIX: '$BRANCH_PREFIX'"
        
        # Use our Git workflow script to handle the entire Git workflow
        # Pass parameters in correct order: ticket, commit_message, pr_title, branch_prefix
        if WORKFLOW_OUTPUT=$(./cli_agents/scripts/git-workflow.sh "full-workflow" "$TICKET_NUMBER" "$COMMIT_MESSAGE" "$PR_TITLE" "$BRANCH_PREFIX" 2>&1); then
          echo "‚úÖ Git workflow completed successfully"
          echo "$WORKFLOW_OUTPUT"
        else
          WORKFLOW_EXIT_CODE=$?
          echo "‚ùå Git workflow failed with exit code $WORKFLOW_EXIT_CODE"
          echo "üìã Git workflow output:"
          echo "$WORKFLOW_OUTPUT"
          exit $WORKFLOW_EXIT_CODE
        fi
        
        # Extract environment variables from the git workflow output
        if echo "$WORKFLOW_OUTPUT" | grep -q "HAS_CHANGES=true"; then
          echo "HAS_CHANGES=true" >> $GITHUB_ENV
          echo "‚úÖ Changes detected - PR will be created"
        else
          echo "HAS_CHANGES=false" >> $GITHUB_ENV
          echo "‚ÑπÔ∏è No changes detected - PR creation skipped"
        fi
        
        if echo "$WORKFLOW_OUTPUT" | grep -q "BRANCH_NAME="; then
          BRANCH_NAME=$(echo "$WORKFLOW_OUTPUT" | grep "BRANCH_NAME=" | cut -d'=' -f2)
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
          echo "üìã Branch name: $BRANCH_NAME"
        fi
        
        if echo "$WORKFLOW_OUTPUT" | grep -q "PR_TITLE="; then
          PR_TITLE=$(echo "$WORKFLOW_OUTPUT" | grep "PR_TITLE=" | cut -d'=' -f2)
          echo "PR_TITLE=$PR_TITLE" >> $GITHUB_ENV
          echo "üìã PR title: $PR_TITLE"
        fi

    - name: Create Pull Request
      if: env.HAS_CHANGES == 'true'
      env:
        GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}
      run: |
        BRANCH_NAME="${{ env.BRANCH_NAME }}"
        PR_TITLE="${{ env.PR_TITLE }}"
        BASE_BRANCH="${{ github.event.inputs.pr_base_branch }}"
        
        echo "üîç PR Creation Debug:"
        echo "- Branch: $BRANCH_NAME"
        echo "- Title: $PR_TITLE"
        echo "- Base: $BASE_BRANCH"
        
        # Get the implementation summary for PR body
        if [ -f "outputs/pr-summary/implementation-summary.md" ]; then
          PR_BODY_FILE="outputs/pr-summary/implementation-summary.md"
        else
          # Fallback to basic description
          echo "# Gemini CLI Implementation" > /tmp/pr-body.md
          echo "" >> /tmp/pr-body.md
          echo "This PR was created automatically by Gemini CLI." >> /tmp/pr-body.md
          echo "" >> /tmp/pr-body.md
          echo "## Original Request" >> /tmp/pr-body.md
          echo "" >> /tmp/pr-body.md
          cat outputs/user-request.txt >> /tmp/pr-body.md
          echo "" >> /tmp/pr-body.md
          echo "## Implementation Details" >> /tmp/pr-body.md
          echo "" >> /tmp/pr-body.md
          echo "Changes were implemented using ${{ github.event.inputs.model }} model." >> /tmp/pr-body.md
          PR_BODY_FILE="/tmp/pr-body.md"
        fi
        
        # Create the pull request using GitHub CLI
        echo "üöÄ Creating pull request..."
        if gh pr create \
          --title "$PR_TITLE" \
          --body-file "$PR_BODY_FILE" \
          --base "$BASE_BRANCH" \
          --head "$BRANCH_NAME"; then
          echo "‚úÖ Pull request created successfully!"
          
          # Try to add labels (non-critical if they fail)
          echo "üè∑Ô∏è Adding labels..."
          gh pr edit "$BRANCH_NAME" --add-label "gemini-cli-generated" || echo "‚ö†Ô∏è Could not add label 'gemini-cli-generated'"
          gh pr edit "$BRANCH_NAME" --add-label "automated-pr" || echo "‚ö†Ô∏è Could not add label 'automated-pr'"
        else
          echo "‚ùå Failed to create pull request"
          exit 1
        fi
        
        # Get the PR URL and number
        PR_URL=$(gh pr view "$BRANCH_NAME" --json url --jq '.url')
        PR_NUMBER=$(gh pr view "$BRANCH_NAME" --json number --jq '.number')
        
        echo "‚úÖ Pull Request created successfully!"
        echo "üîó PR URL: $PR_URL"
        echo "üìã PR Number: #$PR_NUMBER"
        
        # Store for summary
        echo "PR_URL=$PR_URL" >> $GITHUB_ENV
        echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_ENV

    - name: Prepare artifacts for upload
      run: |
        echo "üìã Files available for upload:"
        ls -la outputs/ || echo "‚ùå No outputs directory found"
        echo ""
        echo "üìÑ Response file content preview:"
        if [ -f "outputs/response.md" ]; then
          echo "‚úÖ response.md exists ($(wc -c < outputs/response.md) bytes)"
          head -10 outputs/response.md
        else
          echo "‚ùå response.md not found"
        fi

    - name: Upload execution results as artifact
      uses: actions/upload-artifact@v4
      with:
        name: gemini-cli-results-${{ github.run_number }}
        path: |
          outputs/response.md
          outputs/response-log_*.txt
          outputs/implementation-prompt-combined.md
          outputs/user-request.txt
          outputs/pr_notes.json
          outputs/pr-generation-prompt.md
          outputs/gemini-execution.log
        retention-days: 7
        if-no-files-found: warn

    - name: Display execution summary
      env:
        IMPLEMENTATION_RESPONSE: ${{ steps.gemini_implementation.outputs.gemini_response }}
      run: |
        # Display comprehensive summary
        echo "## üöÄ Gemini CLI Implementation Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Show request details
        echo "### üìã Request Details" >> $GITHUB_STEP_SUMMARY
        echo "- **Model**: ${{ github.event.inputs.model }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Show implementation results
        if [ "${{ env.HAS_CHANGES }}" = "true" ]; then
          echo "### ‚úÖ Implementation Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: Implementation completed with changes" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ env.BRANCH_NAME }}" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ env.PR_NUMBER }}" ]; then
            echo "- **Pull Request**: [#${{ env.PR_NUMBER }}](${{ env.PR_URL }})" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **Pull Request**: Creation in progress..." >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Show clean implementation summary from response.md
          if [ -f "outputs/response.md" ]; then
            echo "### üìä Implementation Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            cat outputs/response.md >> $GITHUB_STEP_SUMMARY
          else
            echo "### üìù Implementation Details" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "$IMPLEMENTATION_RESPONSE" >> $GITHUB_STEP_SUMMARY
          fi
        else
          echo "### ‚ÑπÔ∏è No Changes Made" >> $GITHUB_STEP_SUMMARY
          echo "Gemini CLI completed execution but no code changes were necessary or made." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Show clean response from response.md if available
          if [ -f "outputs/response.md" ]; then
            echo "### üìä Implementation Analysis" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            cat outputs/response.md >> $GITHUB_STEP_SUMMARY
          else
            echo "### üìù Response Details" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "$IMPLEMENTATION_RESPONSE" >> $GITHUB_STEP_SUMMARY
          fi
        fi
