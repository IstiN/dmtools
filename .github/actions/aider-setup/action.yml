name: 'Setup and Run CLI Agent (Aider/Gemini)'
description: 'Common setup for CLI agents with AI models including caching, installation, and execution'

inputs:
  user_request:
    description: 'User request for CLI agent (can be raw text or base64 encoded)'
    required: true
  target_files:
    description: 'Files to include in context (comma-separated, optional)'
    required: false
    default: ''
  model:
    description: 'AI model to use'
    required: false
    default: 'gemini/gemini-2.5-flash-preview-05-20'
  api_key:
    description: 'API key for the AI model'
    required: true
  max_tokens:
    description: 'Maximum tokens for context'
    required: false
    default: '1000000'
  prompt_file:
    description: 'Path to prompt file relative to repo root'
    required: true
  mode:
    description: 'Operation mode: analysis or coding'
    required: false
    default: 'analysis'
  cli_tool:
    description: 'CLI tool to use: aider or gemini'
    required: false
    default: 'aider'

outputs:
  cli_response:
    description: 'Extracted response from CLI agent'
    value: ${{ steps.extract_response.outputs.response }}
  response_found:
    description: 'Whether a valid response was found'
    value: ${{ steps.extract_response.outputs.found }}
  output_file:
    description: 'Path to the execution log file'
    value: ${{ steps.run_cli.outputs.output_file }}

runs:
  using: 'composite'
  steps:
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Cache pip packages
      if: inputs.cli_tool == 'aider'
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-aider-gemini-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-aider-gemini-
          ${{ runner.os }}-pip-

    - name: Cache Aider installation
      if: inputs.cli_tool == 'aider'
      uses: actions/cache@v4
      with:
        path: |
          ~/.local/bin/aider
          ~/.local/share/aider
          ~/.cache/aider
          ~/.aider
        key: ${{ runner.os }}-aider-install-v085-${{ hashFiles('requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-aider-install-v085-
          ${{ runner.os }}-aider-install-
          ${{ runner.os }}-aider-

    - name: Cache Aider repo index
      if: inputs.cli_tool == 'aider'
      uses: actions/cache@v4
      with:
        path: |
          .aider*
          .aider.repo.map
          .aider.tags
        key: ${{ runner.os }}-aider-repo-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-aider-repo-

    - name: Cache npm packages
      if: inputs.cli_tool == 'gemini'
      uses: actions/cache@v4
      with:
        path: ~/.npm
        key: ${{ runner.os }}-npm-gemini-cli-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-npm-gemini-cli-
          ${{ runner.os }}-npm-

    - name: Setup CLI environment
      shell: bash
      env:
        API_KEY: ${{ inputs.api_key }}
      run: |
        ./cli_agents/scripts/setup-cli-env.sh "${{ inputs.cli_tool }}" "${{ inputs.model }}" "$API_KEY"

    - name: Prepare user request
      shell: bash
      env:
        USER_REQUEST_RAW: ${{ inputs.user_request }}
      run: |
        ./cli_agents/scripts/prepare-user-request.sh "$USER_REQUEST_RAW" "outputs"
        
        # Initialize empty discovery file structure for two-phase approach
        if [ "${{ inputs.mode }}" = "coding" ]; then
          echo "🔧 Creating file discovery structure for two-phase implementation"
          cat > outputs/affected-files-template.json << 'TEMPLATE_EOF'
        {
          "request_summary": "",
          "affected_files": {
            "to_modify": [],
            "to_create": [], 
            "to_reference": [],
            "tests_needed": []
          },
          "dependencies": [],
          "implementation_notes": []
        }
        TEMPLATE_EOF
          echo "📝 File discovery template created at outputs/affected-files-template.json"
        fi

    - name: Validate API Key
      shell: bash
      env:
        API_KEY: ${{ inputs.api_key }}
      run: |
        # Check if the API key is provided
        if [ -z "$API_KEY" ]; then
          echo "ERROR: No API key provided."
          exit 1
        fi
        echo "✅ API key validation passed"

    - name: Run CLI Agent
      id: run_cli
      shell: bash
      env:
        GEMINI_API_KEY: ${{ inputs.api_key }}
        GOOGLE_API_KEY: ${{ inputs.api_key }}
        API_KEY: ${{ inputs.api_key }}
      run: |
        if [ "${{ inputs.cli_tool }}" = "aider" ]; then
          OUTPUT_FILE=$(./cli_agents/scripts/run-aider.sh "${{ inputs.prompt_file }}" "outputs/user-request.txt" "${{ inputs.target_files }}" "${{ inputs.model }}" "${{ inputs.max_tokens }}" "${{ inputs.mode }}" "outputs")
          CLI_EXIT_CODE=$?
        elif [ "${{ inputs.cli_tool }}" = "gemini" ]; then
          # For Gemini CLI, determine phase from prompt file
          if [[ "${{ inputs.prompt_file }}" == *"discovery"* ]]; then
            PHASE="discovery"
          elif [[ "${{ inputs.prompt_file }}" == *"implementation"* ]]; then
            PHASE="implementation"
          else
            PHASE="discovery"  # default
          fi
          OUTPUT_FILE=$(./cli_agents/scripts/run-gemini.sh "$PHASE" "outputs/user-request.txt" "${{ inputs.model }}" "false" "false" "outputs")
          CLI_EXIT_CODE=$?
        else
          echo "ERROR: Unknown CLI tool: ${{ inputs.cli_tool }}"
          exit 1
        fi
        
        # Store output file path and exit code for other steps
        echo "output_file=$OUTPUT_FILE" >> $GITHUB_OUTPUT
        echo "cli_exit_code=$CLI_EXIT_CODE" >> $GITHUB_OUTPUT


    - name: Extract CLI response
      id: extract_response
      shell: bash
      run: |
        OUTPUT_FILE="${{ steps.run_cli.outputs.output_file }}"
        CLI_EXIT_CODE="${{ steps.run_cli.outputs.cli_exit_code }}"
        
        # Determine response tag based on CLI tool
        if [ "${{ inputs.cli_tool }}" = "aider" ]; then
          RESPONSE_TAG="AIDER_RESPONSE"
        else
          RESPONSE_TAG="RESPONSE"
        fi
        
        # Use our extract script to get the response
        if EXTRACTED_RESPONSE=$(./cli_agents/scripts/extract-response.sh "$OUTPUT_FILE" "$RESPONSE_TAG" "$CLI_EXIT_CODE"); then
          echo "response<<EOF" >> $GITHUB_OUTPUT
          echo "$EXTRACTED_RESPONSE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "found=true" >> $GITHUB_OUTPUT
        else
          echo "found=false" >> $GITHUB_OUTPUT
        fi
